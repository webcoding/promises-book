<!DOCTYPE html>
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="关于JavaScript Promise基本使用方法以及测试的编写方法、应用及反模式等内容的文档。">
<meta name="keywords" content="JavaScript, ECMAScript, Promise, 日语, 中文, 使用方法, 教程, 参考手册">
<title>JavaScript Promise小书</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
<link rel="stylesheet" href="public/css/font-awesome.min.css">
<style>
/* Foundation stylesheet for CodeRay (to match GitHub theme) | MIT License | http://foundation.zurb.com */
table.CodeRay { border-collapse: collapse; padding: 2px; margin-bottom: 0; border: 0; background: transparent; }
table.CodeRay td { padding: 0 .5em; vertical-align: top; }
table.CodeRay td.line-numbers { text-align: right; color: #999; border-right: 1px solid #e5e5e5; padding-left: 0; }
span.line-numbers { border-right: 1px solid #E5E5E5; color: #999; display: inline-block; margin-right: 0.5em; padding-right: 0.5em; }
.CodeRay td.line-numbers strong, .CodeRay span.line-numbers strong { font-weight: normal; }
.CodeRay .debug { color: white !important; background: blue !important; }
.CodeRay .annotation { color: #007; }
.CodeRay .attribute-name { color: #f08; }
.CodeRay .attribute-value { color: #700; }
.CodeRay .binary { color: #509; }
.CodeRay .comment  { color: #999; font-style: italic; }
.CodeRay .char { color: #04D; }
.CodeRay .char .content { color: #04D; }
.CodeRay .char .delimiter { color: #039; }
.CodeRay .class { color: #458; }
.CodeRay .complex { color: #A08; }
.CodeRay .constant { color: teal; }
.CodeRay .color { color: #0A0; }
.CodeRay .class-variable { color: #369; }
.CodeRay .decorator { color: #B0B; }
.CodeRay .definition { color: #099; }
.CodeRay .directive { color: #088; }
.CodeRay .delimiter { color: black; }
.CodeRay .doc { color: #970; }
.CodeRay .doctype { color: #34b; }
.CodeRay .doc-string { color: #D42; }
.CodeRay .escape  { color: #666; }
.CodeRay .entity { color: #800; }
.CodeRay .error { color: #808; }
.CodeRay .exception { color: #C00; }
.CodeRay .filename { color: #099; }
.CodeRay .function { color: #900; }
.CodeRay .global-variable { color: teal; }
.CodeRay .hex { color: #058; }
.CodeRay .integer  { color: #099; }
.CodeRay .include { color: #B44; }
.CodeRay .inline { color: black; }
.CodeRay .inline .inline { background: #ccc; }
.CodeRay .inline .inline .inline { background: #bbb; }
.CodeRay .inline .inline-delimiter { color: #D14; }
.CodeRay .inline-delimiter { color: #D14; }
.CodeRay .important { color: #f00; }
.CodeRay .interpreted { color: #B2B; }
.CodeRay .instance-variable { color: teal; }
.CodeRay .label { color: #970; }
.CodeRay .local-variable { color: #963; }
.CodeRay .octal { color: #40E; }
.CodeRay .predefined { color: #369; }
.CodeRay .preprocessor { color: #579; }
.CodeRay .pseudo-class { color: #00C; }
.CodeRay .predefined-type { color: #074; }
.CodeRay .reserved, .keyword  { color: #000; }
.CodeRay .key { color: #808; }
.CodeRay .key .delimiter { color: #606; }
.CodeRay .key .char { color: #80f; }
.CodeRay .value { color: #088; }
.CodeRay .regexp { background-color: #fff0ff; }
.CodeRay .regexp .content { color: #808; }
.CodeRay .regexp .delimiter { color: #404; }
.CodeRay .regexp .modifier { color: #C2C; }
.CodeRay .regexp .function  { color: #404; font-weight: bold; }
.CodeRay .string { color: #D20; }
.CodeRay .string .string { }
.CodeRay .string .string .string { background-color: #ffd0d0; }
.CodeRay .string .content { color: #D14; }
.CodeRay .string .char { color: #D14; }
.CodeRay .string .delimiter { color: #D14; }
.CodeRay .shell { color: #D14; }
.CodeRay .shell .content { }
.CodeRay .shell .delimiter { color: #D14; }
.CodeRay .symbol { color: #990073; }
.CodeRay .symbol .content { color: #A60; }
.CodeRay .symbol .delimiter { color: #630; }
.CodeRay .tag, .CodeRay .attribute-name { color: #070; }
.CodeRay .tag-special { color: #D70; }
.CodeRay .type { color: #339; }
.CodeRay .variable  { color: #036; }
.CodeRay .insert { background: #afa; }
.CodeRay .delete { background: #faa; }
.CodeRay .change { color: #aaf; background: #007; }
.CodeRay .head { color: #f8f; background: #505; }
.CodeRay .insert .insert { color: #080; }
.CodeRay .delete .delete { color: #800; }
.CodeRay .change .change { color: #66f; }
.CodeRay .head .head { color: #f4f; }

</style>
<meta name="google-site-verification" content="bMotEbgYwkzA3k4PkuyK_NUdz0bKh-Phz0oUwNmRSVo" />
<script type="text/javascript" src="public/js/google-analytics.js" async></script>
<link rel="canonical" href="http://azu.github.io/promises-book/">
<link rel="alternate" type="application/atom+xml" title="JavaScript Promiseの本" href="https://github.com/azu/promises-book/releases.atom">
<link href="public/img/favicon.ico" rel="shortcut icon" type="image/x-icon">
<link rel="icon" sizes="16x16 32x32" href="public/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="public/css/overload.css"/>
<link rel="stylesheet" type="text/css" href="public/css/codemirror.css"/>
<link rel="stylesheet" type="text/css" href="public/css/mirror-console-compoenent.css">
<script type="text/javascript" src="public/js/build/app.js" async defer></script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>JavaScript Promise小书</h1>
<span id="author" class="author">azu</span><br>
<span id="revnumber">version 1.1.2</span>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">前言</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_">写作初衷</a></li>
<li><a href="#__2">开始阅读之前</a></li>
<li><a href="#__3">格式约定</a></li>
<li><a href="#__4">推荐浏览器</a></li>
<li><a href="#__5">运行示例代码</a></li>
<li><a href="#__license">本书源代码/License</a></li>
<li><a href="#__6">意见和疑问</a></li>
</ul>
</li>
<li><a href="#chapter1-what-is-promise">1. Chapter.1 - 什么是Promise</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#what-is-promise">1.1. What Is Promise</a></li>
<li><a href="#promises-overview">1.2. Promise Overview</a></li>
<li><a href="#how-to-write-promise">1.3. Promiseの書き方</a></li>
</ul>
</li>
<li><a href="#chapter2-how-to-write-promise">2. Chapter.2 - 实战Promise</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#ch2-promise-resolve">2.1. Promise.resolve</a></li>
<li><a href="#ch2-promise-reject">2.2. Promise.reject</a></li>
<li><a href="#promise-is-always-async">2.3. 专栏: Promise只能进行异步操作？</a></li>
<li><a href="#ch2-promise.then">2.4. Promise#then</a></li>
<li><a href="#ch2-promise-catch">2.5. Promise#catch</a></li>
<li><a href="#then-return-new-promise">2.6. コラム: thenは常に新しいpromiseオブジェクトを返す</a></li>
<li><a href="#ch2-promise-and-array">2.7. Promiseと配列</a></li>
<li><a href="#ch2-promise-all">2.8. Promise.all</a></li>
<li><a href="#ch2-promise-race">2.9. Promise.race</a></li>
<li><a href="#then-or-catch">2.10. then or catch?</a></li>
</ul>
</li>
<li><a href="#chapter3-promise-testing">3. Chapter.3 - Promiseのテスト</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#basic-tests">3.1. 基本的なテスト</a></li>
<li><a href="#mocha-promise">3.2. MochaのPromiseサポート</a></li>
<li><a href="#controllable-tests">3.3. 意図したテストを書くには</a></li>
</ul>
</li>
<li><a href="#chapter4-advanced-promise">4. Chapter.4 - Advanced</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#promise-library">4.1. Promiseのライブラリ</a></li>
<li><a href="#resolve-thenable">4.2. Promise.resolveとThenable</a></li>
<li><a href="#not-throw-use-reject">4.3. throwしないで、rejectしよう</a></li>
<li><a href="#deferred-and-promise">4.4. DeferredとPromise</a></li>
<li><a href="#race-delay-timeout">4.5. Promise.raceとdelayによるXHRのキャンセル</a></li>
<li><a href="#promise-done">4.6. Promise.prototype.done とは何か?</a></li>
<li><a href="#promise-and-method-chain">4.7. Promiseとメソッドチェーン</a></li>
<li><a href="#promise-sequence">4.8. Promiseによる逐次処理</a></li>
</ul>
</li>
<li><a href="#promise-api-reference">5. Promises API Reference</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#promise.then">5.1. Promise#then</a></li>
<li><a href="#promise.catch">5.2. Promise#catch</a></li>
<li><a href="#Promise.resolve">5.3. Promise.resolve</a></li>
<li><a href="#Promise.reject">5.4. Promise.reject</a></li>
<li><a href="#Promise.all">5.5. Promise.all</a></li>
<li><a href="#Promise.race">5.6. Promise.race</a></li>
</ul>
</li>
<li><a href="#promise-glossary">6. 用語集</a></li>
<li><a href="#resouce-link">7. 参考サイト</a></li>
<li><a href="#about-author">8. 著者について</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#omake-message">8.1. 著者へのメッセージ/おまけ</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="github-ribbon">
<a href="https://github.com/azu/promises-book/"><img style="border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" /></a>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="https://twitter.com/search?q=%23Promise%E6%9C%AC"><i class="icon-twitter icon-2x"></i></a></span> Hash tag <a href="https://twitter.com/search?q=%23Promise%E6%9C%AC">#Promise本</a></p>
</div>
<div class="paragraph">
<p><span class="icon"><a class="image" href="https://github.com/azu/promises-book/releases.atom"><i class="icon-rss icon-2x"></i></a></span> 可以从这里 <a href="https://github.com/azu/promises-book/releases.atom">RSS</a> 得到更新信息</p>
</div>
<div class="social-button-wrapper">
<iframe src="http://ghbtns.com/github-btn.html?user=azu&repo=promises-book&type=watch&count=true"
  allowtransparency="true" frameborder="0" scrolling="0" width="100" height="20"></iframe>

<a href="https://twitter.com/share" class="twitter-share-button" data-url="http://azu.github.io/promises-book/" data-lang="ja" data-hashtags="Promise本">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

</div>
<div class="paragraph">
<p>本书以Creative Commons Attribution-NonCommercial <a href="https://github.com/azu/promises-book/#license">许可证</a>发布。
另外你也可以从下面的链接下载PDF版本。</p>
</div>
<div class="download-area">
<a class="download-button pdf" id="download-pdf" href="http://azu.github.io/promises-book/javascript-promise-book.pdf" download="javascript-promise-book.pdf">下载本书PDF版本</a>
<a class="download-button source-code" href="https://github.com/azu/promises-book/">下载源代码</a>
</div>
<div class="paragraph">
<p>关于本电子书的创作过程有兴趣的读者，可以下载这个文档供参考 <a href="https://gumroad.com/l/javascript-promise">制作过程</a>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gumroad.com/l/javascript-promise"><img src="./public/img/gumroad-green.svg" alt="附录下载"></a></span> <a href="https://gumroad.com/l/javascript-promise">附录下载</a></p>
</li>
<li>
<p>本书开始编写的原因，如何编写的，以及编写过程是如何运转的。</p>
</li>
<li>
<p>可以在Gumroad上以包括0元在内的任何价格购买本附录内容。</p>
</li>
<li>
<p>如果你想捐赠，也可以使用本附录链接以任意的价格购买本附录即可。</p>
</li>
</ul>
</div>
<hr>
<div style="page-break-after: always;"></div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">前言</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_">写作初衷</h3>
<div class="paragraph">
<p>本书的目的是以目前还在制定中的<a href="#es6-promises">ECMAScript 6 Promises</a>规范为中心，着重向各位读者介绍JavaScript中的Promise相关支持。</p>
</div>
<div class="paragraph">
<p>通过阅读本书，我们希望各位读者能在下面三个目标上有所收获。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>学习Promise相关内容，能熟练使用Promise模式及进行测试</p>
</li>
<li>
<p>学习Promise适合什么不适合什么，知道Promise不是万能的，不能什么都想用Promise来解决</p>
</li>
<li>
<p>以ES6 Promises为基础 を元に基本をよく学び、より発展した形を自分で形成できるようになる事</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>像上面所提到的那样，本书主要是以<a href="#es6-promises">ES6 Promises</a>，即JavaScript的标准规范为基础的Promise相关只是为主要内容。</p>
</div>
<div class="paragraph">
<p>Firefox和Chrome这样技术上比较超前的浏览器不需要安装额外的插件就能使用Promise功能，此外ES6 Promises的规范来源于<a href="#promises-aplus">Promises/A+</a>社区，它有很多版本的实现。</p>
</div>
<div class="paragraph">
<p>我们将会从基础API开始介绍可以在浏览器的原生支持或者通过插件支持的Proise功能。
也希望各位读者能了解这其中Promise适合干什么，不适合干什么，能根据实际需求选择合适的技术实现方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="__2">开始阅读之前</h3>
<div class="paragraph">
<p>本书阅读对象需要对JavaScript有基本的了解和知识。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.oreilly.co.jp/books/9784873113913/">JavaScript: The Good Parts</a></p>
</li>
<li>
<p><a href="http://www.oreilly.co.jp/books/9784873114880/">JavaScript模式</a></p>
</li>
<li>
<p><a href="http://www.oreilly.co.jp/books/9784873115733/">JavaScript 第6版</a></p>
</li>
<li>
<p><a href="http://gihyo.jp/book/2011/978-4-7741-4813-7?ard=1400715177">Perfect JavaScript</a></p>
</li>
<li>
<p><a href="http://books.shoeisha.co.jp/book/b107881.html">Effective JavaScript</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你读过上面的一本书的话，则应该就能非常容易理解本书的内容了。</p>
</div>
<div class="paragraph">
<p>另外如果你有使用JavaScript编写过Web应用程序，或者使用Node.js编写过命令行或服务器程序的话，那么你可能会对本文中的一些内容感到非常熟悉。</p>
</div>
<div class="paragraph">
<p>本书的一本分章节将会以Node.js环境为背景进行说明，如果你有Node.js基础的话，那么一定会非常容易这部分内容了。</p>
</div>
</div>
<div class="sect2">
<h3 id="__3">格式约定</h3>
<div class="paragraph">
<p>本书为了节约篇幅，用了下面一些格式上的约定。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>关于Promise的术语请参考<a href="#promise-glossary">术语集</a>。</p>
<div class="ulist">
<ul>
<li>
<p>一般一个名词第一次出现时都会附带相关链接。</p>
</li>
</ul>
</div>
</li>
<li>
<p>实例方法都用 instance#method 的形式。</p>
<div class="ulist">
<ul>
<li>
<p>比如 <code>Promise#then</code> 这种写法表示的是 Promise的实例对象的 <code>then</code> 这一方法。</p>
</li>
</ul>
</div>
</li>
<li>
<p>对象方法都采用 object.method 的形式。</p>
<div class="ulist">
<ul>
<li>
<p>这沿用了JavaScript中的使用方式，<code>Promise.all</code> 表示的是一个静态方法。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
この部分には文章についての補足が書かれています。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="__4">推荐浏览器</h3>
<div class="paragraph">
<p>我们推荐使用内置对Promise支持的浏览器来阅读本书。</p>
</div>
<div class="paragraph">
<p>Firefox &gt; 29、Chrome &gt; 35 的话都支持<a href="#es6-promises">ES6 Promises</a>标准。</p>
</div>
<div class="paragraph">
<p>此外，虽然不是推荐的阅读环境，但是读者还是能在iOS等移动终端上阅读本书。</p>
</div>
<div class="iframe-wrapper" style="width: 100%; height: 350px; overflow: auto; -webkit-overflow-scrolling: touch;">
<iframe src="http://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>
</div>
</div>
<div class="sect2">
<h3 id="__5">运行示例代码</h3>
<div class="paragraph">
<p>本网站使用了Promise的<a href="#promise-polyfill">Polyfill类库</a>，因此即使在不支持Promise的浏览器上也能执行示例代码。</p>
</div>
<div class="paragraph">
<p>此外像下面这样，各位读者可以通过运行按钮来运行可执行的示例代码。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    resolve(<span class="integer">42</span>);
});
promise.then(<span class="keyword">function</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="tutorial-area">
按下 <button class="mirror-console-button mirror-console-run">运行</button> 按钮之后，代码区会变成编辑区，并开始执行。<br />
<button class="mirror-console-button mirror-console-clear">清除log</button> 按钮用于清除由 <code>console.log</code> 打印出来的log。
<br />
<button class="mirror-console-button mirror-console-exit">退出</button>按钮用来退出编辑模式。
</div>
<div class="paragraph">
<p>如果你对哪里有疑问的话，都可以现场修改并执行，以加深对该代码的理解。</p>
</div>
</div>
<div class="sect2">
<h3 id="__license">本书源代码/License</h3>
<div class="paragraph">
<p>本书中示例代码都可以在GitHub上找到。</p>
</div>
<div class="paragraph">
<p>本书以 <a href="http://asciidoctor.org/">AsciiDoc</a> 形式编写。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book">azu/promises-book</a> <span class="image"><a class="image" href="https://travis-ci.org/azu/promises-book"><img src="https://travis-ci.org/azu/promises-book.svg?branch=master" alt="Build Status"></a></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外代码仓库中还包含本书示例代码的测试代码。</p>
</div>
<div class="paragraph">
<p>源代码的许可证为MIT许可证，文章内容可以基于CC-BY-NC使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="__6">意见和疑问</h3>
<div class="paragraph">
<p>如果有意见或者问题的话，可以直接在GitHub上提Issue即可。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外，你也可以在 <a href="https://gitter.im/azu/promises-book">在线聊天</a> 上留言。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gitter.im/azu/promises-book"><img src="https://badges.gitter.im/azu/promises-book.png" alt="Gitter"></a></span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>各位读者除了能免费阅读本书，也有编辑本书的权利，可以在GitHub上通过GitHubで <a href="https://github.com/azu/promises-book/pulls">Pull Requests</a> 贡献自己的工作。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter1-what-is-promise">1. Chapter.1 - 什么是Promise</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将主要对JavaScript中的Promise进行简单的介绍。</p>
</div>
<div class="sect2">
<h3 id="what-is-promise">1.1. What Is Promise</h3>
<div class="paragraph">
<p>まずPromiseとはそもそもどのようなものでしょうか?</p>
</div>
<div class="paragraph">
<p>Promiseは非同期処理を抽象化したオブジェクトとそれを操作する仕組みの事をいいます。
詳しくはこれから学んでいくとして、PromiseはJavaScriptで発見された概念ではありません。</p>
</div>
<div class="paragraph">
<p>最初に発見されたのは <a href="http://erights.org/elib/distrib/pipeline.html">E言語</a>におけるもので、
並列/並行処理におけるプログラミング言語のデザインの一種です。</p>
</div>
<div class="paragraph">
<p>このデザインをJavaScriptに持ってきたものが、この書籍で学ぶJavaScript Promiseです。</p>
</div>
<div class="paragraph">
<p>一方、JavaScriptにおける非同期処理といえば、コールバックを利用する場合が多いと思います。</p>
</div>
<div class="listingblock">
<div class="title">コールバックを使った非同期処理の一例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">getAsync(<span class="string"><span class="delimiter">&quot;</span><span class="content">fileA.txt</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span>(error, result){<i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">if</span>(error){<span class="comment">// 取得失敗時の処理</span>
        <span class="keyword">throw</span> error;
    }
    <span class="comment">// 取得成功の処理</span>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>コールバック関数の引数には(エラーオブジェクト, 結果)が入る</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Node.js等JavaScriptでのコールバック関数の第一引数には <code>Error</code> オブジェクトを渡すというルールを用いるケースがあります。</p>
</div>
<div class="paragraph">
<p>このようにコールバックでの非同期処理もルールが統一されていた場合、コールバック関数の書き方が明確になります。
しかし、これはあくまでコーディングルールであるため、異なる書き方をしても決して間違いではありません。</p>
</div>
<div class="paragraph">
<p>Promiseでは、このような非同期に対するオブジェクトとルールを仕様化して、
統一的なインターフェースで書くようになっており、それ以外の書き方は出来ないようになっています。</p>
</div>
<div class="listingblock">
<div class="title">Promiseを使った非同期処理の一例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = getAsyncPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">fileA.txt</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
promise.then(<span class="keyword">function</span>(result){
    <span class="comment">// 取得成功の処理</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    <span class="comment">// 取得失敗時の処理</span>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>promiseオブジェクトを返す</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>非同期処理を抽象化したpromiseオブジェクトというものを用意し、
そのpromiseオブジェクトに対して成功時の処理と失敗時の処理の関数を登録するようにして使います。</p>
</div>
<div class="paragraph">
<p>コールバック関数と比べると何が違うのかを簡単に見ると、
非同期処理の書き方がpromiseオブジェクトのインターフェースに沿った書き方に限定されます。</p>
</div>
<div class="paragraph">
<p>つまり、promiseオブジェクトに用意されてるメソッド(ここでは <code>then</code> や <code>catch</code>)以外は使えないため、
コールバックのように引数に何を入れるかが自由に決められるわけではなく、一定のやり方に統一されます。</p>
</div>
<div class="paragraph">
<p>この、Promiseという統一されたインターフェースがあることで、
そのインターフェースにおける様々な非同期処理のパターンを形成することが出来ます。</p>
</div>
<div class="paragraph">
<p>つまり、複雑な非同期処理等を上手くパターン化できるというのがPromiseの役割であり、
Promiseを使う理由の一つであるといえるでしょう。</p>
</div>
<div class="paragraph">
<p>それでは、実際にJavaScriptでのPromiseについて学んでいきましょう。</p>
</div>
</div>
<div class="sect2">
<h3 id="promises-overview">1.2. Promise Overview</h3>
<div class="paragraph">
<p>以<a href="#es6-promises">ES6 Promises</a>的式样来定义的API还没有那么多 。</p>
</div>
<div class="paragraph">
<p>大致可以分为下面三种类型。</p>
</div>
<div class="paragraph">
<p><strong>Constructor</strong></p>
</div>
<div class="paragraph">
<p>Promise类似于 <code>XMLHttpRequest</code>、从构造函数<code>Promise</code> 来新建实例。
生成promise对象后才能使用。</p>
</div>
<div class="paragraph">
<p>生成promise对象、要使用<code>new</code>来实例化<code>Promise</code> 构造器  。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject) {
    <span class="comment">// 非同期处理</span>
    <span class="comment">// 处理结束后、调用resolve 或 reject</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instance Method</strong></p>
</div>
<div class="paragraph">
<p>对通过new生成的promise对象为了设置其值在 <strong>resolve</strong>(成功) / <strong>reject</strong>(失败)时调用的回调函数
可以使用<code>promise.then()</code> 实例方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(onFulfilled, onRejected)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">resolve(成功)时</dt>
<dd>
<p><code>onFulfilled</code> 会被调用</p>
</dd>
<dt class="hdlist1">reject(失敗)した時</dt>
<dd>
<p><code>onRejected</code>  会被调用</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>onFulfilled</code>、<code>onRejected</code> 两个都为可选参数。</p>
</div>
<div class="paragraph">
<p><code>promise.then</code> 成功和失败时都可以使用。
还有、只想添加异常处理时和 <code>promise.then(undefined, onRejected)</code> 的用法一样。
<code>promise.catch(onRejected)</code> 这样也可以使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.<span class="keyword">catch</span>(onRejected)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Static Method</strong></p>
</div>
<div class="paragraph">
<p>像<code>Promise</code> 这样的全局对象拥有几个静态方法。</p>
</div>
<div class="paragraph">
<p><code>Promise.all()</code> 还有 <code>Promise.resolve()</code> 等、主要用来作为在操作Promise时的辅助方法。</p>
</div>
<div class="sect3">
<h4 id="_promise_workflow">1.2.1. Promise workflow</h4>
<div class="paragraph">
<p>来看下下面的示例代码。</p>
</div>
<div id="promise-workflow.js" class="listingblock executable">
<div class="title">promise-workflow.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">asyncFunction</span>() {
    <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        setTimeout(<span class="keyword">function</span> () {
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">Async Hello world</span><span class="delimiter">'</span></span>);
        }, <span class="integer">16</span>);
    });
}
<i class="conum" data-value="2"></i><b>(2)</b>
asyncFunction().then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 'Async Hello world'</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.log(error);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Promiseコンストラクタを <code>new</code> して、promiseオブジェクトを返します</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&lt;1&gt;のpromiseオブジェクトに対して <code>.then</code> で値が返ってきた時のコールバックを設定します</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>asyncFunction</code> という関数 は promiseオブジェクトを返していて、
そのpromiseオブジェクトに対して <code>then</code> でresolveした時のコールバックを、
<code>catch</code> でエラーとなった場合のコールバックを設定しています。</p>
</div>
<div class="paragraph">
<p>このpromiseオブジェクトはsetTimeoutで16ms後にresolveされるので、
そのタイミングで <code>then</code> のコールバックが呼ばれ <code>'Async Hello world'</code> と出力されます。</p>
</div>
<div class="paragraph">
<p>この場合 <code>catch</code> のコールバックは呼ばれる事はないですが、
<code>setTimeout</code> が存在しない環境などでは、例外が発生し <code>catch</code> で登録したコールバック関数が呼ばれると思います。</p>
</div>
<div class="paragraph">
<p>もちろん、<code>promise.then(onFulfilled, onRejected)</code> というように、
<code>catch</code> を使わずに <code>then</code> を使い、以下のように2つのコールバック関数を設定することでもほぼ同様の動作になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">asyncFunction().then(<span class="keyword">function</span> (value) {
    console.log(value);
}, <span class="keyword">function</span> (error) {
    console.log(error);
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="promise-states">1.2.2. Promiseの状態</h4>
<div class="paragraph">
<p>Promiseの処理の流れが少しわかった所で、少しPromiseの状態について整理したいと思います。</p>
</div>
<div class="paragraph">
<p><code>new Promise</code> でインスタンス化したpromiseオブジェクトには以下の3つの状態が存在します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">"has-resolution" - Fulfilled</dt>
<dd>
<p>resolve(成功)した時。この時 <code>onFulfilled</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">"has-rejection"  - Rejected</dt>
<dd>
<p>reject(失敗)した時。この時 <code>onRejected</code>  が呼ばれる</p>
</dd>
<dt class="hdlist1">"unresolved" - Pending</dt>
<dd>
<p>resolveまたはrejectではない時。つまりpromiseオブジェクトが作成された初期状態等が該当する</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>読み方ですが、
左が<a href="#es6-promises">ES6 Promises</a>の仕様で定められている名前で、
右が<a href="#promises-aplus">Promises/A+</a>で登場する状態の名前になっています。</p>
</div>
<div class="paragraph">
<p>基本的にこの状態をプログラムで直接触る事はないため、名前自体は余り気にしなくても問題ないです。
この書籍では、 <a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a> の <em>Pending</em>、<em>Fulfilled</em> 、<em>Rejected</em>
を用いて解説していきます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch1_WhatsPromises/img/promise-states.png" alt="promise-states">
</div>
<div class="title">Figure 1. promise states</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">ECMAScript Language Specification ECMA-262 6th Edition – DRAFT</a> では <code>[[PromiseStatus]]</code> という内部定義によって状態が定められています。
<code>[[PromiseStatus]]</code> にアクセスするユーザーAPIは用意されていないため、基本的には知る方法はありません。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>3つの状態を見たところで、既にこの章で全ての状態が出てきていることが分かります。</p>
</div>
<div class="paragraph">
<p>promiseオブジェクトの状態は、一度<em>Pending</em>から<em>Fulfilled</em>や<em>Rejected</em>になると、
そのpromiseオブジェクトの状態はそれ以降変化することはなくなります。</p>
</div>
<div class="paragraph">
<p>つまり、PromiseはEvent等とは違い、<code>.then</code> で登録した関数が呼ばれるのは1回限りという事が明確になっています。</p>
</div>
<div class="paragraph">
<p>また、<em>Fulfilled</em>と<em>Rejected</em>のどちらかの状態であることを<strong>Settled</strong>(不変の)と表現することがあります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Settled</dt>
<dd>
<p>resolve(成功) または reject(失敗) した時。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><em>Pedding</em>と<em>Settled</em>が対となる関係であると考えると、Promiseの状態の種類/遷移がシンプルであることがわかると思います。</p>
</div>
<div class="paragraph">
<p>このpromiseオブジェクトの状態が変化した時に、一度だけ呼ばれる関数を登録するのが <code>.then</code> といったメソッドとなるわけです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</a>
というスライドではPromiseの状態遷移について分かりやすく書かれています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-to-write-promise">1.3. Promiseの書き方</h3>
<div class="paragraph">
<p>Promiseの基本的な書き方について解説します。</p>
</div>
<div class="sect3">
<h4 id="_promise">1.3.1. promiseオブジェクトの作成</h4>
<div class="paragraph">
<p>promiseオブジェクトを作る流れは以下のようになっています。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>new Promise(fn)</code> の返り値がpromiseオブジェクト</p>
</li>
<li>
<p><code>fn</code> には非同期等の何らかの処理を書く</p>
<div class="ulist">
<ul>
<li>
<p>処理結果が正常なら、<code>resolve(結果の値)</code> を呼ぶ</p>
</li>
<li>
<p>処理結果がエラーなら、<code>reject(Errorオブジェクト)</code> を呼ぶ</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>この流れに沿っているものを実際に書いてみましょう。</p>
</div>
<div class="paragraph">
<p>非同期処理であるXMLHttpRequest(XHR)を使いデータを取得するものをPromiseで書いていきます。</p>
</div>
<div class="sect4">
<h5 id="_xhr_promise">XHRのpromiseオブジェクトを作る</h5>
<div class="paragraph">
<p>まずは、XHRをPromiseを使って包んだような <code>getURL</code> という関数を作ります。</p>
</div>
<div id="xhr-promise.js" class="listingblock executable">
<div class="title">xhr-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="comment">// 実行例</span>
<span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>getURL</code> では、
XHRでの取得結果のステータスコードが200の場合のみ <code>resolve</code> - つまり取得に成功、
それ以外はエラーであるとして <code>reject</code> しています。</p>
</div>
<div class="paragraph">
<p><code>resolve(req.response)</code> ではレスポンスの内容を引数に入れています。
resolveの引数に入れる値には特に決まりはありませんが、コールバックと同様に次の処理へ渡したい値を入れるといいでしょう。
(この値は <code>then</code> メソッドで受け取ることが出来ます)</p>
</div>
<div class="paragraph">
<p>Node.jsをやっている人は、コールバックを書く時に <code>callback(error, response)</code> と第一引数にエラーオブジェクトを
入れることがよくあると思いますが、Promiseでは役割がresolve/rejectで分担されているので、
resolveにはresponseの値のみをいれるだけで問題ありません。</p>
</div>
<div class="paragraph">
<p>次に、<code>reject</code> の方を見て行きましょう。</p>
</div>
<div class="paragraph">
<p>XHRで <code>onerror</code> のイベントが呼ばれた場合はもちろんエラーなので <code>reject</code> を呼びます。
ここで <code>reject</code> に渡している値に注目してみてください。</p>
</div>
<div class="paragraph">
<p>エラーの場合は <code>reject(new Error(req.statusText));</code> というように、Errorオブジェクトを作成して渡している事がわかると思います。
<code>reject</code> に渡す値に制限はありませんが、一般的にErrorオブジェクト(またはErrorオブジェクトを継承したもの)を渡すことになっています。</p>
</div>
<div class="paragraph">
<p><code>reject</code> に渡す値は、rejectする理由を書いたErrorオブジェクトとなっています。
今回は、ステータスコードが200以外であるならrejectするとしていたため、<code>reject</code> にはstatusTextを入れています。
(この値は <code>then</code> メソッドの第二引数 or <code>catch</code> メソッドで受け取ることが出来ます)</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_2">1.3.2. promiseオブジェクトに処理を書く</h4>
<div class="paragraph">
<p>先ほどの作成したpromiseオブジェクトを返す関数を実際に使ってみましょう</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">getURL(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://example.com/</span><span class="delimiter">&quot;</span></span>); <span class="comment">// =&gt; promiseオブジェクトが返ってくる</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#promises-overview">Promises Overview</a> でも簡単に紹介したようにpromiseオブジェクトは幾つかインスタンスメソッドを持っており、
これを使いpromiseオブジェクトの状態に応じて一度だけ呼ばれるコールバックとなる関数を登録します。</p>
</div>
<div class="paragraph">
<p>promiseオブジェクトに登録する処理は以下の2種類が主となります</p>
</div>
<div class="ulist">
<ul>
<li>
<p>promiseオブジェクトが <strong>resolve</strong> された時の処理(onFulfilled)</p>
</li>
<li>
<p>promiseオブジェクトが <strong>reject</strong> された時の処理(onRejected)</p>
</li>
</ul>
</div>
<div id="promise-value-flow" class="imageblock">
<div class="content">
<img src="Ch1_WhatsPromises/img/promise-onFulfilled_onRejected.png" alt="promise-resolve-flow">
</div>
<div class="title">Figure 2. promise value flow</div>
</div>
<div class="paragraph">
<p>まずは、<code>getURL</code> で通信が成功して値が取得出来た場合の処理を書いてみましょう。</p>
</div>
<div class="paragraph">
<p>この場合の <em>通信が成功した</em> というのは、
resolveされたことにより<em>promiseオブジェクトがFulFilledの状態になった</em> 時という事ですね。</p>
</div>
<div class="paragraph">
<p><strong>resolve</strong>された時の処理は、 <a href="#promise.then"><code>.then</code></a> メソッドに呼ばれたい関数を渡すことで行えます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){ <i class="conum" data-value="1"></i><b>(1)</b>
    console.log(value);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>分かりやすくするため関数に <code>onFulfilled</code> という名前を付けています</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#xhr-promise.js">getURL関数</a> 内で <code>resolve(req.response);</code> によってpromiseオブジェクトが解決されると、
値と共に <code>onFulfilled</code> 関数が呼ばれます。</p>
</div>
<div class="paragraph">
<p>このままでは通信エラーが起きた場合などに何も処理がされないため、
今度は、<code>getURL</code> で何らかの問題があってエラーが起きた場合の処理を書いてみましょう。</p>
</div>
<div class="paragraph">
<p>この場合の <em>エラーが起きた</em> というのは、
rejectされたことより<em>promiseオブジェクトがRejectedの状態になった</em>時という事ですね。</p>
</div>
<div class="paragraph">
<p><strong>reject</strong>された時の処理は、<a href="#promise.then"><code>.then</code> の第二引数</a> または <a href="#promise.catch"><code>.catch</code></a> メソッドに呼ばれたい関数を渡す事で行えます。</p>
</div>
<div class="paragraph">
<p>先ほどのソースにrejectされた場合の処理を追加してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/status/500</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){ <i class="conum" data-value="2"></i><b>(2)</b>
    console.error(error);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>サーバはステータスコード500のレスポンスを返す</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>分かりやすくするため関数 <code>onRejected</code> という名前を付けています</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>getURL</code> の処理中に何らかの理由で例外が起きた場合、または明示的にrejectされた場合に、
その理由(Errorオブジェクト)と共に <a href="#promise.catch"><code>.catch</code></a> の処理が呼ばれます。</p>
</div>
<div class="paragraph">
<p><a href="#promise.catch"><code>.catch</code></a>は <code>promise.then(undefined, onRejected)</code> のエイリアスであるため、
同様の処理は以下のように書くことも出来ます。</p>
</div>
<div id="catch-as-alias" class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">getURL(URL).then(onFulfilled, onRejected);<i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>onFulfilled, onRejected それぞれは先ほどと同じ関数</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>基本的には、<a href="#promise.catch"><code>.catch</code></a>を使いresolveとrejectそれぞれを別々に処理した方がよいと考えられますが、
両者の違いについては <a href="#then-or-catch">thenとcatchの違い</a> で紹介します。</p>
</div>
<div class="sect4">
<h5 id="__7">まとめ</h5>
<div class="paragraph">
<p>この章では以下のことについて簡単に紹介しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>new Promise</code> を使ったpromiseオブジェクトの作成</p>
</li>
<li>
<p><a href="#promise.then"><code>.then</code></a> や <a href="#promise.catch"><code>.catch</code></a> を使ったpromiseオブジェクトの処理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Promiseの基本的な書き方について学びました。
他の多くの処理はこれを発展させたり、用意された静的メソッドを利用したものになります。</p>
</div>
<div class="paragraph">
<p>ここでは、同様の事はコールバック関数を渡す形でも出来るのに対してPromiseで書くメリットについては触れていませんでした。
次の章では、Promiseのメリットであるエラーハンドリングの仕組みをコールバックベースの実装と比較しながら見て行きたいと思います。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter2-how-to-write-promise">2. Chapter.2 - 实战Promise</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章我们将会学习Promise提供的各种方法以及如何进行错误处理。</p>
</div>
<div class="sect2">
<h3 id="ch2-promise-resolve">2.1. Promise.resolve</h3>
<div class="paragraph">
<p>一般情况下我们都会使用 <code>new Promise()</code> 来创建promise对象，但是除此之外我们也可以使用其他方法。</p>
</div>
<div class="paragraph">
<p>在这里，我们将会学习如何使用 <a href="#Promise.resolve"><code>Promise.resolve</code></a> 和 <a href="#Promise.reject"><code>Promise.reject</code></a>这两个方法。</p>
</div>
<div class="sect3">
<h4 id="_new_promise">2.1.1. new Promise的快捷方式</h4>
<div class="paragraph">
<p>静态方法<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 可以认为是
<code>new Promise()</code> 方法的快捷方式。</p>
</div>
<div class="paragraph">
<p>比如 <code>Promise.resolve(42);</code> 可以认为是以下代码的语法糖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    resolve(<span class="integer">42</span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这段代码中的 <code>resolve(42);</code> 会让这个promise对象立即进入确定（即resolved）状态，并将 <code>42</code> 传递给后面then里所指定的 <code>onFulfilled</code> 函数。</p>
</div>
<div class="paragraph">
<p>方法 <code>Promise.resolve(value);</code> 的返回值也是一个promise对象，所以我们可以像下面那样接着对其返回值进行 <code>.then</code> 调用。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(<span class="integer">42</span>).then(<span class="keyword">function</span>(value){
    console.log(value);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve">Promise.resolve</a>作为 <code>new Promise()</code> 的快捷方式，在进行promise对象的初始化或者编写测试代码的生活都非常方便。</p>
</div>
</div>
<div class="sect3">
<h4 id="_thenable">2.1.2. Thenable</h4>
<div class="paragraph">
<p><code>Promise.resolve</code> 方法另一个作用就是将 <a href="#Thenable">thenable</a> 对象转换为promise对象。</p>
</div>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a>里提到了<a href="#Thenable">Thenable</a>这个概念，简单来说它就是一个非常类似promise的东西。</p>
</div>
<div class="paragraph">
<p>就像我们有时称具有 <code>.length</code> 方法的非数组对象为Array like一样，thenable指的是一个具有 <code>.then</code> 方法的对象。</p>
</div>
<div class="paragraph">
<p>这种将thenable对象转换为promise对象的机制要求thenable对象所拥有的 <code>then</code> 方法应该和Promise所拥有的 <code>then</code> 方法具有同样的功能和处理过程，在将thenable对象转换为promise对象的时候，还会巧妙的利用thenable对象原来具有的 <code>then</code> 方法。</p>
</div>
<div class="paragraph">
<p>到底什么样的对象能算是thenable的呢，最简单的例子就是
<a href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</a>，它的返回值就是thenable的。</p>
</div>
<div class="paragraph">
<p>因为<code>jQuery.ajax()</code> 的返回值是 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a> 对象，这个对象具有 <code>.then</code> 方法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="predefined">$</span>.ajax(<span class="string"><span class="delimiter">'</span><span class="content">/json/comment.json</span><span class="delimiter">'</span></span>);<span class="comment">// =&gt; 拥有 `.then` 方法的对象</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个thenable的对象可以使用 <code>Promise.resolve</code> 来转换为一个promise对象。</p>
</div>
<div class="paragraph">
<p>变成了promise对象的话，就能直接使用 <code>then</code> 或者 <code>catch</code> 等这些在
<a href="#es6-promises">ES6 Promises</a>里定义的方法了。</p>
</div>
<div class="listingblock">
<div class="title">将thenable对象转换promise对象</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve(<span class="predefined">$</span>.ajax(<span class="string"><span class="delimiter">'</span><span class="content">/json/comment.json</span><span class="delimiter">'</span></span>));<span class="comment">// =&gt; promise对象</span>
promise.then(<span class="keyword">function</span>(value){
   console.log(value);
});</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">jQuery和thenable</div>
<div class="paragraph">
<p><a href="https://api.jquery.com/jQuery.ajax/">jQuery.ajax()</a>的返回值是一个具有 <code>.then</code> 方法的 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR Object</a>对象，这个对象继承了来自 <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a> 的方法和属性。</p>
</div>
<div class="paragraph">
<p>但是Deferred Object并没有遵循<a href="#promises-aplus">Promises/A+</a>或<a href="#es6-promises">ES6 Promises</a>标准，所以即使看上去这个对象转换成了一个promise对象，但是会出席缺失部分信息的问题。</p>
</div>
<div class="paragraph">
<p>这个问题的根源在于jQuery的 <a href="http://api.jquery.com/category/deferred-object/">Deferred Object</a> 的 <code>then</code> 方法机制与promise不同。</p>
</div>
<div class="paragraph">
<p>所以我们应该注意，即使一个对象具有 <code>.then</code> 方法，也不一定就能作为ES6 Promises对象使用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.html5rocks.com/en/tutorials/es6/promises/#toc-lib-compatibility">JavaScript Promises: There and back again - HTML5 Rocks</a></p>
</li>
<li>
<p><a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">You&#39;re Missing the Point of Promises</a></p>
</li>
<li>
<p><a href="https://twitter.com/hirano_y_aa/status/398851806383452160">https://twitter.com/hirano_y_aa/status/398851806383452160</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Promise.resolve</code> 只使用了共通的方法 <code>then</code> ，提供了在不同的类库之间进行promise对象互相转换的功能。</p>
</div>
<div class="paragraph">
<p>这种转换为thenable的功能在之前是通过使用 <code>Promise.cast</code> 来完成的，从它的名字我们也不能想象它的功能是什么。</p>
</div>
<div class="paragraph">
<p>除了在编写使用Promise的类库等软件时需要对Thenable有所了解之外，通常的时候我们可能不会用到此功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>结合使用了Thenable和Promise.resolve的具体例子我们会在后面第4章的<a href="#resolve-thenable">Promise.resolve和Thenable</a>中进行详细的说明。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>简单总结一下 <code>Promise.resolve</code> 方法的话，可以认为它的作用就是将传递给它的参数填充（Fulfilled）到promise对象后并返回这个promise对象。</p>
</div>
<div class="paragraph">
<p>此外，Promise的很多处理内部也是使用了 <code>Promise.resolve</code> 算法将值转换为promise对象后再进行处理的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-reject">2.2. Promise.reject</h3>
<div class="paragraph">
<p><a href="#Promise.reject"><code>Promise.reject(error)</code></a>是和
<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 类似的静态方法，是 <code>new Promise()</code> 方法的快捷方式。</p>
</div>
<div class="paragraph">
<p>比如 <code>Promise.reject(new Error("出错了"))</code> 就是下面代码的语法糖形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve,reject){
    reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">出错了</span><span class="delimiter">&quot;</span></span>));
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码的功能是调用该promise对象通过then指定的 <code>onRejected</code> 函数，并将错误（Error）对象传递给这个 <code>onRejected</code> 函数。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">BOOM!</span><span class="delimiter">&quot;</span></span>)).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>它和<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 的不同之处在于promise内调用的函数式reject而不是resolve，这在编写测试代码或者进行debug时，说不定会用得上。</p>
</div>
</div>
<div class="sect2">
<h3 id="promise-is-always-async">2.3. 专栏: Promise只能进行异步操作？</h3>
<div class="paragraph">
<p>在使用<a href="#Promise.resolve"><code>Promise.resolve(value)</code></a> 等方法的饿时候，如果promise对象立刻就能resolve的话，那么你是不是觉得 <code>.then</code> 里面指定的方法就是同步调用的呢？</p>
</div>
<div class="paragraph">
<p>但实际上 <code>.then</code> 中指定的方法调用是异步进行的。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">inner promise</span><span class="delimiter">&quot;</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
    resolve(<span class="integer">42</span>);
});
promise.then(<span class="keyword">function</span>(value){
    console.log(value); <i class="conum" data-value="3"></i><b>(3)</b>
});
console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">outer promise</span><span class="delimiter">&quot;</span></span>);<i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>执行上面的代码会输出下面的log，从这些log我们清楚地知道了上面代码的执行顺序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>inner promise
outer promise
42</pre>
</div>
</div>
<div class="paragraph">
<p>由于JavaScript代码会按照文件的从上到下的顺序执行，所以最开始 <code>&lt;1&gt;</code> 会执行，然后是 <code>resolve(42);</code> 被执行。这时候 <code>promise</code> 对象的已经变为确定状态，FulFilled被设置为了 <code>42</code> 。</p>
</div>
<div class="paragraph">
<p>下面的代码 <code>promise.then</code> 注册了 <code>&lt;3&gt;</code> 这个回调函数，这是本专栏的焦点问题。</p>
</div>
<div class="paragraph">
<p>由于 <code>promise.then</code> 执行的时候promise对象已经是确定状态，从程序上说对回调函数进行同步调用也是行得通的。</p>
</div>
<div class="paragraph">
<p>但是即使在调用 <code>promise.then</code> 注册回调函数的时候promise对象已经是确定的状态，Promise也会以异步的方式调用该毁掉函数，这是在Promise设计上就决定了方针。</p>
</div>
<div class="paragraph">
<p>因此 <code>&lt;2&gt;</code> 会最先被调用，最后才会调用回调函数 <code>&lt;3&gt;</code> 。</p>
</div>
<div class="paragraph">
<p>为什么要对明明可以以同步方式进行调用的函数，非要使用异步的调用方式呢？</p>
</div>
<div class="sect3">
<h4 id="__8">2.3.1. 同步调用和异步调用同时存在导致的混乱</h4>
<div class="paragraph">
<p>其实在Promise之外也存在这个问题，这里我们以一般的使用情况来考虑此问题。</p>
</div>
<div class="paragraph">
<p>这个问题的本质是接收回调函数的函数，会根据具体的执行情况，可以选择是以同步还是异步的方式对回调函数进行调用。</p>
</div>
<div class="paragraph">
<p>下面我们以 <code>onReady(fn)</code> 为例进行说明，这个函数会接收一个回调函数进行处理。</p>
</div>
<div id="mixed-onready.js" class="listingblock executable">
<div class="title">mixed-onready.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">onReady</span>(fn) {
    <span class="keyword">var</span> readyState = document.readyState;
    <span class="keyword">if</span> (readyState == <span class="string"><span class="delimiter">'</span><span class="content">interactive</span><span class="delimiter">'</span></span> || readyState === <span class="string"><span class="delimiter">'</span><span class="content">complete</span><span class="delimiter">'</span></span>) {
        fn();
    } <span class="keyword">else</span> {
        window.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>, fn);
    }
}
onReady(<span class="keyword">function</span> () {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">'</span></span>);
});
console.log(<span class="string"><span class="delimiter">'</span><span class="content">==Starting==</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#mixed-onready.js">mixed-onready.js</a>会根据执行时的DOM是否装载完毕来决定是对回调函数进行同步或者是异步的调用。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">如果在调用onReady之前DOM已经载入的话</dt>
<dd>
<p>对回调函数进行同步调用</p>
</dd>
<dt class="hdlist1">如果在调用onReady之前DOM还没有载入的话</dt>
<dd>
<p>通过注册 <code>DOMContentLoaded</code> 事件监听器来对回调函数进行异步调用</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>因此，如果这段代码在源文件中出现的位置不同，在控制台上打印的log消息顺序也会不同。</p>
</div>
<div class="paragraph">
<p>为了解决这个问题，我们可以选择统一使用异步调用方法。</p>
</div>
<div id="async-onready.js" class="listingblock executable">
<div class="title">async-onready.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">onReady</span>(fn) {
    <span class="keyword">var</span> readyState = document.readyState;
    <span class="keyword">if</span> (readyState == <span class="string"><span class="delimiter">'</span><span class="content">interactive</span><span class="delimiter">'</span></span> || readyState === <span class="string"><span class="delimiter">'</span><span class="content">complete</span><span class="delimiter">'</span></span>) {
        setTimeout(fn, <span class="integer">0</span>);
    } <span class="keyword">else</span> {
        window.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>, fn);
    }
}
onReady(<span class="keyword">function</span> () {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">'</span></span>);
});
console.log(<span class="string"><span class="delimiter">'</span><span class="content">==Starting==</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于这个问题，在 <a href="http://effectivejs.com/">Effective JavaScript</a> 的 <strong>第67项 不要对异步回调函数进行同步调用</strong> 中也有详细介绍。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="ulist">
<ul>
<li>
<p>绝对不能对异步回调函数（即使在数据已经就绪）进行同步调用。</p>
</li>
<li>
<p>如果对异步回调函数进行同步调用的话，处理顺序可能会与预期不符，可能带来意料之外的后果。</p>
</li>
<li>
<p>对异步回调函数进行同步调用，还可能导致栈溢出或异常处理错乱等问题。</p>
</li>
<li>
<p>如果想在将来某时刻调用异步回调函数的话，可以使用 <code>setTimeout</code> 等异步API。</p>
</li>
</ul>
</div>
</blockquote>
<div class="attribution">
<cite>Effective JavaScript</cite><br>
&#8212; David Herman
</div>
</div>
<div class="paragraph">
<p>前面我们看到的 <code>promise.then</code> 也属于此类，为了不编码上述的同步异步调用可能引起的混乱，Promise在规范上规定 <strong>Promise只能使用异步调用方式</strong> 。</p>
</div>
<div class="paragraph">
<p>最后，将上面的 <code>onReady</code> 函数用Promise重写的话，代码如下面所示。</p>
</div>
<div id="onready-as-promise.js" class="listingblock executable">
<div class="title">onready-as-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">onReadyPromise</span>() {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> readyState = document.readyState;
        <span class="keyword">if</span> (readyState == <span class="string"><span class="delimiter">'</span><span class="content">interactive</span><span class="delimiter">'</span></span> || readyState === <span class="string"><span class="delimiter">'</span><span class="content">complete</span><span class="delimiter">'</span></span>) {
            resolve();
        } <span class="keyword">else</span> {
            window.addEventListener(<span class="string"><span class="delimiter">'</span><span class="content">DOMContentLoaded</span><span class="delimiter">'</span></span>, resolve);
        }
    });
}
onReadyPromise().then(<span class="keyword">function</span> () {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">DOM fully loaded and parsed</span><span class="delimiter">'</span></span>);
});
console.log(<span class="string"><span class="delimiter">'</span><span class="content">==Starting==</span><span class="delimiter">'</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于Promise保证了每次调用都是以异步方式进行的，所以我们在实际编码中不需要调用 <code>setTimeout</code> 来自己实现异步调用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise.then">2.4. Promise#then</h3>
<div class="paragraph">
<p>先ほどの章でPromiseの基本となるインスタンスメソッドである <code>then</code> と <code>catch</code> の使い方を説明しました。</p>
</div>
<div class="paragraph">
<p>その中で <code>.then().catch()</code> とメソッドチェーンで繋げて書いていたことからもわかるように、
Promiseではいくらでもメソッドチェーンを繋げて処理を書いていくことが出来ます。</p>
</div>
<div class="listingblock">
<div class="title">promiseはメソッドチェーンで繋げて書ける</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">aPromise.then(<span class="keyword">function</span> <span class="function">taskA</span>(value){
<span class="comment">// task A</span>
}).then(<span class="keyword">function</span> <span class="function">taskB</span>(vaue){
<span class="comment">// task B</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span> <span class="function">onRejected</span>(error){
    console.log(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>then</code> で登録するコールバック関数をそれぞれtaskというものにした時に、
taskA &#8594; task B という流れをPromiseのメソッドチェーンを使って書くことが出来ます。</p>
</div>
<div class="paragraph">
<p>Promiseのメソッドチェーンだと長いので、今後は<a href="#promise-chain">promise chain</a>と呼びます。
このpromise chainがPromiseが非同期処理の流れを書きやすい理由の一つといえるかもしれません。</p>
</div>
<div class="paragraph">
<p>このセクションでは、<code>then</code> を使ったpromise chainの挙動と流れについて学んでいきましょう。</p>
</div>
<div class="sect3">
<h4 id="_promise_chain">2.4.1. promise chain</h4>
<div class="paragraph">
<p>第一章の例だと、<a href="#promise-chain">promise chain</a>は
then &#8594; catch というシンプルな例でしたが、このpromise chainをもっとつなげた場合に、
それぞれのpromiseオブジェクトに登録された onFulfilledとonRejectedがどのように呼ばれるかを見て行きましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
promise chain - すなわちメソッドチェーンが短い事は良いことです。
この例では説明のために長いメソッドチェーンを用います。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>次のようなpromise chainを見てみましょう。</p>
</div>
<div id="promise-then-catch-flow.js" class="listingblock executable">
<div class="title">promise-then-catch-flow.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">taskA</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task A</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">taskB</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task B</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">onRejected</span>(error) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Catch Error: A or B</span><span class="delimiter">&quot;</span></span>, error);
}
<span class="keyword">function</span> <span class="function">finalTask</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final Task</span><span class="delimiter">&quot;</span></span>);
}

<span class="keyword">var</span> promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .<span class="keyword">catch</span>(onRejected)
    .then(finalTask);</code></pre>
</div>
</div>
<div class="paragraph">
<p>このようなpromise chainをつなげた場合、
それぞれの処理の流れは以下のように図で表せます。</p>
</div>
<div id="promise-then-catch-flow.png" class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-then-catch-flow.png" alt="promise-then-catch-flow">
</div>
<div class="title">Figure 3. promise-then-catch-flow.jsの図</div>
</div>
<div class="paragraph">
<p><a href="#promise-then-catch-flow.js">上記のコード</a>では <code>then</code> は第二引数(onRejected)を使っていないため、
以下のように読み替えても問題ありません。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>then</code></dt>
<dd>
<p>onFulfilledの処理を登録</p>
</dd>
<dt class="hdlist1"><code>catch</code></dt>
<dd>
<p>onRejectedの処理を登録</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><a href="#promise-then-catch-flow.png">図</a>の方に注目してもらうと、
<em>Task A</em> と <em>Task B</em> それぞれから <em>onRejected</em> への線が出ていることが分かります。</p>
</div>
<div class="paragraph">
<p>これは、<em>Task A</em> または <em>Task B</em> の処理にて、次のような場合に <em>onRejected</em> が呼ばれるという事を示しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>例外が発生した時</p>
</li>
<li>
<p>Rejectedなpromiseオブジェクトがreturnされた時</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#how-to-write-promise">第一章</a>でPromiseの処理は常に <code>try-catch</code> されているようなものなので、
例外が起きた場合もキャッチして、<code>catch</code> で登録された <code>onRejected</code> の処理を呼ぶことは学びましたね。</p>
</div>
<div class="paragraph">
<p>もう一つの <em>Rejectedなpromiseオブジェクトがreturnされた時</em> については、
<code>throw</code> を使わずにpromise chain中に <code>onRejected</code> を呼ぶ方法です。</p>
</div>
<div class="paragraph">
<p>これについては、ここでは必要ない内容なので詳しくは、 第4章の <a href="#not-throw-use-reject">throwしないで、rejectしよう</a> にて解説しています。</p>
</div>
<div class="paragraph">
<p>また、<em>onRejected</em> と <em>Final Task</em> には <code>catch</code> のpromise chainがこれより後ろにありません。
つまり、この処理中に例外が起きた場合はキャッチすることができないことに気をつけましょう。</p>
</div>
<div class="paragraph">
<p>もう少し具体的に、<em>Task A</em> &#8594; <em>onRejected</em> となる例を見てみます。</p>
</div>
<div class="sect4">
<h5 id="_task_a">Task Aで例外が発生したケース</h5>
<div class="paragraph">
<p><em>Task A</em> の処理中に例外が発生した場合、
TaskA &#8594; onRejected &#8594; FinalTask という流れで処理が行われます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-taska-rejected-flow.png" alt="promise taska rejected flow">
</div>
<div class="title">Figure 4. Task Aで例外が発生した時の図</div>
</div>
<div class="paragraph">
<p>コードにしてみると以下のようになります。</p>
</div>
<div id="promise-then-taska-throw.js" class="listingblock executable">
<div class="title">promise-then-taska-throw.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">taskA</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task A</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">throw Error @ Task A</span><span class="delimiter">&quot;</span></span>)
}
<span class="keyword">function</span> <span class="function">taskB</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Task B</span><span class="delimiter">&quot;</span></span>);<span class="comment">// 呼ばれない</span>
}
<span class="keyword">function</span> <span class="function">onRejected</span>(error) {
    console.log(error);<span class="comment">// =&gt; &quot;throw Error @ Task A&quot;</span>
}
<span class="keyword">function</span> <span class="function">finalTask</span>() {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">Final Task</span><span class="delimiter">&quot;</span></span>);
}

<span class="keyword">var</span> promise = Promise.resolve();
promise
    .then(taskA)
    .then(taskB)
    .<span class="keyword">catch</span>(onRejected)
    .then(finalTask);</code></pre>
</div>
</div>
<div class="paragraph">
<p>実行してみると、<em>Task B</em> が呼ばれていない事がわかるでしょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>例では説明のためにtaskAで <code>throw</code> して例外を発生させています。
しかし、実際に明示的にonRejectedを呼びたい場合は、Rejectedなpromiseオブジェクトを返すべきでしょう。
それぞれの違いについては <a href="#not-throw-use-reject">throwしないで、rejectしよう</a> で解説しています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_chain_2">2.4.2. promise chainでの値渡し</h4>
<div class="paragraph">
<p>先ほどの例ではそれぞれのTaskが独立していて、ただ呼ばれているだけでした。</p>
</div>
<div class="paragraph">
<p>この時に、Task AがTask Bへ値を渡したい時はどうすれば良いでしょうか?</p>
</div>
<div class="paragraph">
<p>答えはものすごく単純でTask Aの処理で <code>return</code> した値がTask Bが呼ばれるときに引数に設定されます。</p>
</div>
<div class="paragraph">
<p>実際に例を見てみましょう。</p>
</div>
<div id="promise-then-passing-value.js" class="listingblock executable">
<div class="title">promise-then-passing-value.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">doubleUp</span>(value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}
<span class="keyword">function</span> <span class="function">increment</span>(value) {
    <span class="keyword">return</span> value + <span class="integer">1</span>;
}
<span class="keyword">function</span> <span class="function">output</span>(value) {
    console.log(value);<span class="comment">// =&gt; (1 + 1) * 2</span>
}

<span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);
promise
    .then(increment)
    .then(doubleUp)
    .then(output);</code></pre>
</div>
</div>
<div class="paragraph">
<p>スタートは <code>Promise.resolve(1);</code> で、この処理は以下のような流れでpromise chainが処理されていきます。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Promise.resolve(1);</code> から 1 が <code>increment</code> に渡される</p>
</li>
<li>
<p><code>increment</code> では渡された値に+1した値を <code>return</code> している</p>
</li>
<li>
<p>この値(2)が次の <code>doubleUp</code> に渡される</p>
</li>
<li>
<p>最後に <code>output</code> が出力する</p>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/promise-then-passing-value.png" alt="promise-then-passing-value">
</div>
<div class="title">Figure 5. promise-then-passing-value.jsの図</div>
</div>
<div class="paragraph">
<p>この <code>return</code> する値は数字や文字列だけではなく、
オブジェクトやpromiseオブジェクトも <code>return</code> することが出来ます。</p>
</div>
<div class="paragraph">
<p>returnした値は <code>Promise.resolve(returnされた値);</code> のように処理されるため、
何をreturnしても最終的には新しいpromiseオブジェクトを返します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
これについて詳しくは <a href="#then-return-new-promise">thenは常に新しいpromiseオブジェクトを返す</a> にて、
よくある間違いと共に紹介しています。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>つまり、 <code>Promise#then</code> は単にコールバックとなる関数を登録するだけではなく、
受け取った値を変化させて別のpromiseオブジェクトを生成する という機能も持っていることを覚えておくといいでしょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-catch">2.5. Promise#catch</h3>
<div class="paragraph">
<p><a href="#ch2-promise.then">先ほどのPromise#then</a>についてでも <code>Promise#catch</code> は既に使っていましたね。</p>
</div>
<div class="paragraph">
<p>改めて説明すると<a href="#promise.catch">Promise#catch</a>は <code>promise.then(undefined, onRejected);</code> のエイリアスとなるメソッドです。
つまり、promiseオブジェクトがRejectedとなった時に呼ばれる関数を登録するためのメソッドです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#promise.then">Promise#then</a>と<a href="#promise.catch">Promise#catch</a>の使い分けについては、
<a href="#then-or-catch">then or catch?</a>で紹介しています。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_ie8">2.5.1. IE8以下での問題</h4>
<div class="paragraph">
<p><span class="image"><a class="image" href="https://ci.testling.com/azu/promise-catch-error"><img src="Ch2_HowToWrite/img/promise-catch-error.png" alt="Build Status"></a></span></p>
</div>
<div class="paragraph">
<p>このバッジは以下のコードが、 <a href="https://github.com/jakearchibald/es6-promise">polyfill</a> を用いた状態でそれぞれのブラウザで正しく実行できているかを示したものです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>polyfillとはその機能が実装されていないブラウザでも、その機能が使えるようにするライブラリのことです。
この例では <a href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</a> を利用しています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock executable">
<div class="title">Promise#catchの実行結果</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise.<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコードをそれぞれのブラウザで実行させると、IE8以下では実行する段階で <strong>識別子がありません</strong> というSyntax Errorになってしまいます。</p>
</div>
<div class="paragraph">
<p>これはどういう事かというと、<code>catch</code> という単語はECMAScriptにおける <a href="http://mothereff.in/js-properties#catch">予約語</a> であることが関係します。</p>
</div>
<div class="paragraph">
<p>ECMAScript 3では予約語はプロパティの名前に使うことが出来ませんでした。
IE8以下はECMAScript 3の実装であるため、<code>catch</code> というプロパティを使う <code>promise.catch()</code> という書き方が出来ないため、
<strong>識別子がありません</strong>というエラーを起こしてしまう訳です。</p>
</div>
<div class="paragraph">
<p>一方、現在のブラウザが実装済みであるECMAScript 5以降では、
予約語を <a href="http://es5.github.io/#x7.6">IdentifierName</a> 、つまりプロパティ名に利用することが可能となっています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECMAScript5でも予約語は <a href="http://es5.github.io/#x7.6">Identifier</a> 、つまり変数名、関数名には利用することが出来ません。
<code>for</code> という変数が定義できてしまうと <code>for</code> 文との区別ができなくなってしまいます。
プロパティの場合は <code>object.for</code> と <code>for</code> 文の区別はできるので、少し考えてみると自然な動作ですね。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このECMAScript 3の予約語の問題を回避する書き方も存在します。</p>
</div>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation">ドット表記法</a>
はプロパティ名が有効な識別子(ECMAScript 3の場合は予約語が使えない)でないといけませんが、
<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Bracket_notation">ブラケット表記法</a>
は有効な識別子ではなくても利用できます。</p>
</div>
<div class="paragraph">
<p>つまり、先ほどのコードは以下のように書き換えれば、IE8以下でも実行することが出来ます。(もちろんpolyfillは必要です)</p>
</div>
<div class="listingblock executable">
<div class="title">Promise#catchの識別子エラーの回避</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>](<span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>もしくは単純に <code>catch</code> を使わずに、<code>then</code> を使うことでも回避できます。</p>
</div>
<div class="listingblock executable">
<div class="title">Promise#catchではなくPromise#thenを使う</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
promise.then(<span class="predefined-constant">undefined</span>, <span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>catch</code> という識別子が問題となっているため、ライブラリによっては <code>caught</code> 等の名前が違うだけのメソッドを用意しているケースがあります。</p>
</div>
<div class="paragraph">
<p>サポートブラウザにIE8以下を含める時は、この <code>catch</code> の問題に気をつけるといいでしょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="then-return-new-promise">2.6. コラム: thenは常に新しいpromiseオブジェクトを返す</h3>
<div class="paragraph">
<p><code>aPromise.then(...).catch(...)</code> は一見すると、全て最初の <code>aPromise</code> オブジェクトに
メソッドチェーンで処理を書いてるように見えます。</p>
</div>
<div class="paragraph">
<p>しかし、実際には <code>then</code> で新しいpromiseオブジェクト、<code>catch</code> でも別の新しいpromiseオブジェクトを作成して返しています。</p>
</div>
<div class="paragraph">
<p>本当に新しいpromiseオブジェクトを返しているのか確認してみましょう。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
    resolve(<span class="integer">100</span>);
});
<span class="keyword">var</span> thenPromise = aPromise.then(<span class="keyword">function</span> (value) {
    console.log(value);
});
<span class="keyword">var</span> catchPromise = thenPromise.<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});
console.log(aPromise !== thenPromise); <span class="comment">// =&gt; true</span>
console.log(thenPromise !== catchPromise);<span class="comment">// =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>===</code> 厳密比較演算子によって比較するとそれぞれが別々のオブジェクトなので、
本当に <code>then</code> や <code>catch</code> は別のpromiseオブジェクトを返していることが分かりました。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
</div>
<div class="paragraph">
<p>この仕組みはPromiseを拡張する時は意識しないと、いつのまにか触ってるpromiseオブジェクトが
別のものであったという事が起こりえると思います。</p>
</div>
<div class="paragraph">
<p>また、<code>then</code> は新しいオブジェクトを作って返すということがわかっていれば、
次の <code>then</code> の使い方では意味が異なる事に気づくでしょう。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="comment">// 1: それぞれの `then` は同時に呼び出される</span>
<span class="keyword">var</span> aPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
    resolve(<span class="integer">100</span>);
});
aPromise.then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
});
aPromise.then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
});
aPromise.then(<span class="keyword">function</span> (value) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">1: </span><span class="delimiter">&quot;</span></span> + value); <span class="comment">// =&gt; 100</span>
})

<span class="comment">// vs</span>

<span class="comment">// 2: `then` はpromise chain通り順番に呼び出される</span>
<span class="keyword">var</span> bPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
    resolve(<span class="integer">100</span>);
});
bPromise.then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}).then(<span class="keyword">function</span> (value) {
    <span class="keyword">return</span> value * <span class="integer">2</span>;
}).then(<span class="keyword">function</span> (value) {
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">2: </span><span class="delimiter">&quot;</span></span> + value); <span class="comment">// =&gt; 100 * 2 * 2</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>1のpromiseをメソッドチェーン的に繋げない書き方はあまりすべきではありませんが、
このような書き方をした場合、それぞれの <code>then</code> はほぼ同時に呼ばれ、また <code>value</code> に渡る値も全て同じ <code>100</code> となります。</p>
</div>
<div class="paragraph">
<p>2はメソッドチェーン的につなげて書くことにより、resolve &#8594; then &#8594; then &#8594; then と書いた順番にキチンと実行され、
それぞれの <code>value</code> に渡る値は、一つ前のpromiseオブジェクトで <code>return</code> された値が渡ってくるようになります。</p>
</div>
<div class="paragraph">
<p>1の書き方により発生するアンチパターンとしては以下のようなものが有名です。</p>
</div>
<div class="listingblock">
<div class="title">✘ <code>then</code> の間違った使い方</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">anAsyncCall</span>() {
    <span class="keyword">var</span> promise = Promise.resolve();
    promise.then(<span class="keyword">function</span>() {
        <span class="comment">// 何かの処理</span>
        <span class="keyword">return</span> newVar;
    });
    <span class="keyword">return</span> promise;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように書いてしまうと、<code>promise.then</code> の中で例外が発生するとその例外を取得する方法がなくなり、
また、何かの値を返していてもそれを受け取る方法が無くなってしまいます。</p>
</div>
<div class="paragraph">
<p>これは <code>promise.then</code> によって新たに作られたpromiseオブジェクトを返すようにすることで、
2のようにpromise chainをつなげるようにするべきなので、次のように修正することが出来ます。</p>
</div>
<div class="listingblock">
<div class="title"><code>then</code> で作成したオブジェクトを返す</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">anAsyncCall</span>() {
    <span class="keyword">var</span> promise = Promise.resolve();
    <span class="keyword">return</span> promise.then(<span class="keyword">function</span>() {
        <span class="comment">// 何かの処理</span>
        <span class="keyword">return</span> newVar;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これらのアンチパターンについて、詳しくは
<a href="http://taoofcode.net/promise-anti-patterns/">Promise Anti-patterns</a> を参照して下さい。</p>
</div>
<div class="paragraph">
<p>この挙動はPromise全般に当てはまるため、後に説明する<a href="#ch2-promise-all">Promise.all</a>や<a href="#ch2-promise-race">Promise.race</a>も
引数で受け取ったものとは別のpromiseオブジェクトを作って返しています。</p>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-and-array">2.7. Promiseと配列</h3>
<div class="paragraph">
<p>ここまでで、promiseオブジェクトが FulFilled または Rejected となった時の処理は <a href="#promise.then"><code>.then</code></a> と <a href="#promise.catch"><code>.catch</code></a> で登録出来る事を学びました。</p>
</div>
<div class="paragraph">
<p>一つのpromiseオブジェクトなら、そのpromiseオブジェクトに対して処理を書けば良いですが、
複数のpromiseオブジェクトが全てFulFilledとなった時の処理を書く場合はどうすればよいでしょうか?</p>
</div>
<div class="paragraph">
<p>例えば、複数のXHR(非同期処理)が全て終わった後に、何かをしたいという事例を考えてみます。</p>
</div>
<div class="paragraph">
<p>少しイメージしにくいので、
まずは、通常のコールバックスタイルを使って複数のXHRを行う以下のようなコードを見てみます。</p>
</div>
<div class="sect3">
<h4 id="__9">2.7.1. コールバックで複数の非同期処理</h4>
<div id="multiple-xhr-callback.js" class="listingblock executable">
<div class="title">multiple-xhr-callback.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURLCallback</span>(URL, callback) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
    req.<span class="function">onload</span> = <span class="keyword">function</span> () {
        <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
            callback(<span class="predefined-constant">null</span>, req.response);
        } <span class="keyword">else</span> {
            callback(<span class="keyword">new</span> Error(req.statusText), req.response);
        }
    };
    req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
        callback(<span class="keyword">new</span> Error(req.statusText));
    };
    req.send();
}
<span class="comment">// &lt;1&gt; JSONパースを安全に行う</span>
<span class="keyword">function</span> <span class="function">jsonParse</span>(callback, error, value) {
    <span class="keyword">if</span> (error) {
        callback(error, value);
    } <span class="keyword">else</span> {
        <span class="keyword">try</span> {
            <span class="keyword">var</span> result = JSON.parse(value);
            callback(<span class="predefined-constant">null</span>, result);
        } <span class="keyword">catch</span> (e) {
            callback(e, value);
        }
    }
}
<span class="comment">// &lt;2&gt; XHRを叩いてリクエスト</span>
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>(callback) {
            <span class="keyword">return</span> getURLCallback(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>, jsonParse.bind(<span class="predefined-constant">null</span>, callback));
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>(callback) {
            <span class="keyword">return</span> getURLCallback(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>, jsonParse.bind(<span class="predefined-constant">null</span>, callback));
        }
    };
<span class="comment">// &lt;3&gt; 複数のXHRリクエストを行い、全部終わったらcallbackを呼ぶ</span>
<span class="keyword">function</span> <span class="function">allRequest</span>(requests, callback, results) {
    <span class="keyword">if</span> (requests.length === <span class="integer">0</span>) {
        <span class="keyword">return</span> callback(<span class="predefined-constant">null</span>, results);
    }
    <span class="keyword">var</span> req = requests.shift();
    req(<span class="keyword">function</span> (error, value) {
        <span class="keyword">if</span> (error) {
            callback(error, value);
        } <span class="keyword">else</span> {
            results.push(value);
            allRequest(requests, callback, results);
        }
    });
}
<span class="keyword">function</span> <span class="function">main</span>(callback) {
    allRequest([request.comment, request.people], callback, []);
}
<span class="comment">// 実行例</span>
main(<span class="keyword">function</span>(error, results){
    <span class="keyword">if</span>(error){
        <span class="keyword">return</span> console.error(error);
    }
    console.log(results);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコールバックスタイルでは幾つかの要素が出てきます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON.parse</code> をそのまま使うと例外となるケースがあるためラップした <code>jsonParse</code> 関数を使う</p>
</li>
<li>
<p>複数のXHRをそのまま書くとネストが深くなるため、<code>allRequest</code> というrequest関数を実行するものを利用する</p>
</li>
<li>
<p>コールバック関数には <code>callback(error,value)</code> というNode.jsでよく見られる引数を渡す</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>jsonParse</code> 関数を使うときに <code>bind</code> を使うことで、部分適用を使って無名関数を減らすようにしています。
(コールバックスタイルでも関数の処理などをちゃんと分離すれば、無名関数の使用も減らせると思います)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">jsonParse.bind(<span class="predefined-constant">null</span>, callback);
<span class="comment">// は以下のように置き換えるのと殆ど同じ</span>
<span class="keyword">function</span> <span class="function">bindJSONParse</span>(error, value){
    jsonParse(callback, error, value);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>コールバックスタイルで書いたものを見ると以下のような点が気になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>明示的な例外のハンドリングが必要</p>
</li>
<li>
<p>ネストを深くしないために、requestを扱う関数が必要</p>
</li>
<li>
<p>コールバックがたくさんでてくる</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>次は、<code>Promise#then</code> を使って同様の事をしてみたいと思います。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_then">2.7.2. Promise#thenのみで複数の非同期処理</h4>
<div class="paragraph">
<p>先に述べておきますが、<code>Promise.all</code> というこのような処理に適切なものがあるため、
ワザと <code>.then</code> の部分をクドく書いています。</p>
</div>
<div class="paragraph">
<p><a href="#promise.then"><code>.then</code></a> を使った場合は、コールバックスタイルと完全に同等というわけではないですが以下のように書けると思います。</p>
</div>
<div id="multiple-xhr.js" class="listingblock executable">
<div class="title">multiple-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] は記録する初期値を部分適用している</span>
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);
}
<span class="comment">// 実行例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#multiple-xhr-callback.js">コールバックスタイル</a>と比較してみると次の事がわかります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JSON.parse</code> をそのまま使っている</p>
</li>
<li>
<p><code>main()</code> はpromiseオブジェクトを返している</p>
</li>
<li>
<p>エラーハンドリングは返ってきたpromiseオブジェクトに対して書いている</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>先ほども述べたように mainの <code>then</code> の部分がクドく感じます。</p>
</div>
<div class="paragraph">
<p>Promiseでは、このような複数の非同期処理をまとめて扱う <code>Promise.all</code> と <code>Promise.race</code> という静的メソッドが用意されています。</p>
</div>
<div class="paragraph">
<p>次のセクションではそれらについて学んでいきましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-all">2.8. Promise.all</h3>
<div class="paragraph">
<p><a href="#Promise.all"><code>Promise.all</code></a> は promiseオブジェクトの配列を受け取り、
その配列に入っているpromiseオブジェクトが全てresolveされた時に、次の <code>.then</code> を呼び出します。</p>
</div>
<div class="paragraph">
<p>先ほどの複数のXHRの結果をまとめて取得する処理は、 <a href="#Promise.all"><code>Promise.all</code></a> を使うとシンプルに書くことができます。</p>
</div>
<div class="paragraph">
<p>先ほどの例の <code>getURL</code> はXHRによる通信を抽象化したpromiseオブジェクトを返しています。
<code>Promise.all</code> に通信を抽象化したpromiseオブジェクトの配列を渡すことで、
全ての通信が完了(FulFilledまたRejected)した時に、次の <code>.then</code> が呼び出すこと事が出来ます。</p>
</div>
<div id="promise-all-xhr.js" class="listingblock executable">
<div class="title">promise-all-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">return</span> Promise.all([request.comment(), request.people()]);
}
<span class="comment">// 実行例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.log(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>実行方法は <a href="#xhr-promise.js">前回のもの</a> と同じですね。
<a href="#Promise.all"><code>Promise.all</code></a> を使うことで以下のような違いがあることがわかります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>mainの処理がスッキリしている</p>
</li>
<li>
<p>Promise.all は promiseオブジェクトの配列を扱っている</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.all([request.comment(), request.people()]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>というように処理を書いた場合は、<code>request.comment()</code> と <code>request.people()</code> は同時に実行されますが、
それぞれのpromiseの結果(resolve,rejectで渡される値)は、<a href="#Promise.all"><code>Promise.all</code></a>に渡した配列の順番となります。</p>
</div>
<div class="paragraph">
<p>つまり、この場合に次の <code>.then</code> に渡される結果の配列は [comment, people]の順番になることが保証されています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">main().then(<span class="keyword">function</span> (results) {
    console.log(results); <span class="comment">// [comment, people]の順番</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#Promise.all"><code>Promise.all</code></a> に渡したpromiseオブジェクトが同時に実行されてるのは、
次のようなタイマーを使った例を見てみると分かりやすいです。</p>
</div>
<div id="promise-all-timer.js" class="listingblock executable">
<div class="title">promise-all-timer.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="comment">// `delay`ミリ秒後にresolveする</span>
<span class="keyword">function</span> <span class="function">timerPromisefy</span>(delay) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            resolve(delay);
        }, delay);
    });
}
<span class="keyword">var</span> startDate = Date.now();
<span class="comment">// 全てがresolveされたら終了</span>
Promise.all([
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
]).then(<span class="keyword">function</span> (values) {
    console.log(Date.now() - startDate + <span class="string"><span class="delimiter">'</span><span class="content">ms</span><span class="delimiter">'</span></span>);
    <span class="comment">// 約128ms</span>
    console.log(values);    <span class="comment">// [1,32,64,128]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>timerPromisefy</code> は引数で指定したミリ秒後に、その指定した値でFulFilledとなる
promiseオブジェクトを返してくれます。</p>
</div>
<div class="paragraph">
<p><code>Promise.all</code> に渡してるのは、それを複数作り配列にしたものですね。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promises = [
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>この場合は、1, 32, 64, 128 ミリ秒後にそれぞれ <code>resolve</code> されます。</p>
</div>
<div class="paragraph">
<p>つまり、このpromiseオブジェクトの配列がすべてresolveされるには、最低でも128msかかることがわかります。
実際に<a href="#Promise.all"><code>Promise.all</code></a> で処理してみると 約128msかかる事がわかります。</p>
</div>
<div class="paragraph">
<p>この事から、<a href="#Promise.all"><code>Promise.all</code></a> が一つづつ順番にやるわけではなく、
渡されたpromiseオブジェクトの配列を並列に実行してるという事がわかります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仮に逐次的に行われていた場合は、
1ms待機 &#8594; 32ms待機 &#8594; 64ms待機 &#8594; &#8230; &#8594; 128ms待機 となるので、
全て完了するまで225ms程度かかる計算になります。</p>
</div>
<div class="paragraph">
<p>実際にPromiseを逐次的に処理したいケースについては第4章の<a href="#promise-sequence">Promiseによる逐次処理</a>を参照して下さい。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="ch2-promise-race">2.9. Promise.race</h3>
<div class="paragraph">
<p>接着我们来看看和 <a href="#Promise.all"><code>Promise.all</code></a> 类似的对多个promise对象进行处理的 <a href="#Promise.race"><code>Promise.race</code></a> 方法。</p>
</div>
<div class="paragraph">
<p>它的使用方法和Promise.all一样，接收一个promise对象数组参数。</p>
</div>
<div class="paragraph">
<p><code>Promise.all</code> 在接收到的所有的对象promise都变为 FulFilled 或者 Rejected 状态之后才会继续进行后面的处理，
与之相对的是 <code>Promise.race</code> 只要有一个promise对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
</div>
<div class="paragraph">
<p>像Promise.all时的例子一样，我们来看一个带计时器的 <code>Promise.race</code> 的使用例子。</p>
</div>
<div id="promise-race-timer.js" class="listingblock executable">
<div class="title">promise-race-timer.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="comment">// `delay`ミリ秒後にresolveする</span>
<span class="keyword">function</span> <span class="function">timerPromisefy</span>(delay) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            resolve(delay);
        }, delay);
    });
}
<span class="comment">// 一つでもresolve または reject した時点で終了</span>
Promise.race([
    timerPromisefy(<span class="integer">1</span>),
    timerPromisefy(<span class="integer">32</span>),
    timerPromisefy(<span class="integer">64</span>),
    timerPromisefy(<span class="integer">128</span>)
]).then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 1</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码4个promise对象，这些对象会分别在1ms，32ms，64ms和128ms后变为确定状态，即FulFilled，并且在第一个变为确定状态的1ms后， <code>.then</code> 注册的回调函数就会被调用，这时候确定状态的promise对象会调用 <code>resolve(1)</code> 因此传递给 <code>value</code> 的值也是1，控制台上会打印出1来。</p>
</div>
<div class="paragraph">
<p>下面我们再来看看在第一个promise对象变为确定（FulFilled）状态后，它之后的promise对象是否还在继续运行。</p>
</div>
<div id="promise-race-other.js" class="listingblock executable">
<div class="title">promise-race-other.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> winnerPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
        }, <span class="integer">4</span>);
    });
<span class="keyword">var</span> loserPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
        }, <span class="integer">1000</span>);
    });
<span class="comment">// 一番最初のものがresolveされた時点で終了</span>
Promise.race([winnerPromise, loserPromise]).then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 'this is winner'</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在前面代码的基础上增加了 <code>console.log</code> 用来输出调试信息。</p>
</div>
<div class="paragraph">
<p>执行上面代码的话，我们会看到 winnter和loser promise对象的 <code>setTimeout</code> 方法都会执行完毕， <code>console.log</code> 也会分别输出它们的信息。</p>
</div>
<div class="paragraph">
<p>也就是说， <a href="#Promise.race"><code>Promise.race</code></a> 在第一个promise对象变为Fulfilled之后，并不会取消其他promise对象的执行。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
在 <a href="#es6-promises">ES6 Promises</a> 规范中，也没有取消promise对象执行的概念，我们必须要确保promise最终进入resolve or reject状态之一。也就是说Promise并不适用于 <a href="#promise-states">状态</a> 可能会固定不变的处理。也有一些类库提供了对promise进行取消的操作。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="then-or-catch">2.10. then or catch?</h3>
<div class="paragraph">
<p><a href="#catch-as-alias">前の章</a>で <a href="#promise.catch"><code>.catch</code></a> は  <code>promise.then(undefined, onRejected)</code> であるという事を紹介しました。</p>
</div>
<div class="paragraph">
<p>この書籍では基本的には、<a href="#promise.catch"><code>.catch</code></a>を使い <a href="#promise.then"><code>.then</code></a> とは分けてエラーハンドリングを書くようにしています。</p>
</div>
<div class="paragraph">
<p>ここでは、<code>.then</code> でまとめて指定した場合と、どのような違いがでるかについて学んでいきましょう。</p>
</div>
<div class="sect3">
<h4 id="__onrejected">2.10.1. エラー処理ができないonRejected</h4>
<div class="paragraph">
<p>次のようなコードを見ていきます。</p>
</div>
<div id="then-throw-error.js" class="listingblock executable">
<div class="title">then-throw-error.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">throwError</span>(value) {
    <span class="comment">// 例外を投げる</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(value);
}
<span class="comment">// &lt;1&gt; onRejectedが呼ばれることはない</span>
<span class="keyword">function</span> <span class="function">badMain</span>(onRejected) {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then(throwError, onRejected);
}
<span class="comment">// &lt;2&gt; onRejectedが例外発生時に呼ばれる</span>
<span class="keyword">function</span> <span class="function">goodMain</span>(onRejected) {
    <span class="keyword">return</span> Promise.resolve(<span class="integer">42</span>).then(throwError).<span class="keyword">catch</span>(onRejected);
}
<span class="comment">// 実行例</span>
badMain(<span class="keyword">function</span>(){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">BAD</span><span class="delimiter">&quot;</span></span>);
});
goodMain(<span class="keyword">function</span>(){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">GOOD</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このコード例では、(必ずしも悪いわけではないですが)良くないパターンの <code>badMain</code> と
ちゃんとエラーハンドリングが行える <code>goodMain</code> があります。</p>
</div>
<div class="paragraph">
<p><code>badMain</code> がなぜ良くないかというと、<code>.then</code> の第二引数にはエラー処理を書くことが出来ますが、
そのエラー処理は第一引数の <code>onFulfilled</code> で指定した関数内で起きたエラーをキャッチする事は出来ません。</p>
</div>
<div class="paragraph">
<p>つまり、この場合、 <code>throwError</code> でエラーがおきても、<code>onRejected</code> に指定した関数は呼ばれることなく、
どこでエラーが発生したのかわからなくなってしまいます。</p>
</div>
<div class="paragraph">
<p>それに対して、 <code>goodMain</code> は <code>throwError</code>&#8594;<code>onRejected</code> となるように書かれています。
この場合は <code>throwError</code> でエラーが発生しても、次のchainである <code>.catch</code> が呼ばれるため、エラーハンドリングを行う事が出来ます。</p>
</div>
<div class="paragraph">
<p><code>.then</code> のonRejectedが扱う処理は、その(またはそれ以前の)promiseオブジェクトに対してであって、
<code>.then</code> に書かれたonFulfilledは対象ではないためこのような違いが生まれます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>.then</code> や <code>.catch</code> はその場で<strong>新しい</strong>promiseオブジェクトを作って返します。
Promiseではchainする度に異なるpromiseオブジェクトに対して処理を書くようになっています。</p>
</div>
</td>
</tr>
</table>
</div>
<div id="then-catch-flow" class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
<div class="title">Figure 6. Then Catch flow</div>
</div>
<div class="paragraph">
<p>この場合の <code>then</code> は <code>Promise.resolve(42)</code> に対する処理となり、
<code>onFulfilled</code> で例外が発生しても、同じ <code>then</code> で指定された <code>onRejected</code> はキャッチすることはありません。</p>
</div>
<div class="paragraph">
<p>この <code>then</code> で発生した例外をキャッチ出来るのは、次のchainで書かれた <code>catch</code> となります。</p>
</div>
<div class="paragraph">
<p>もちろん <code>.catch</code> は <code>.then</code> のエイリアスなので、下記のように <code>.then</code> を使っても問題はありませんが、
<code>.catch</code> を使ったほうが意図が明確で分かりやすいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(<span class="integer">42</span>).then(throwError).then(<span class="predefined-constant">null</span>, onRejected);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__10">2.10.2. まとめ</h4>
<div class="paragraph">
<p>ここでは次のような事について学びました。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>promise.then(onFulfilled, onRejected)</code> において</p>
<div class="ulist">
<ul>
<li>
<p><code>onFulfilled</code> で例外がおきても、この <code>onRejected</code> はキャッチできない</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>promise.then(onFulfilled).catch(onRejected)</code> とした場合</p>
<div class="ulist">
<ul>
<li>
<p><code>then</code> で発生した例外を <code>.catch</code> でキャッチできる</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#promise.then"><code>.then</code></a>と<a href="#promise.catch"><code>.catch</code></a>に本質的な意味の違いはない</p>
<div class="ulist">
<ul>
<li>
<p>使い分けると意図が明確になる</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>badMain</code> のような書き方をすると、意図とは異なりエラーハンドリングができないケースが存在することは覚えておきましょう。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter3-promise-testing">3. Chapter.3 - Promiseのテスト</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章ではPromiseのテストの書き方について学んで行きます。</p>
</div>
<div class="sect2">
<h3 id="basic-tests">3.1. 基本的なテスト</h3>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a>のメソッド等についてひと通り学ぶことができたため、
実際にPromiseを使った処理を書いていくことは出来ると思います。</p>
</div>
<div class="paragraph">
<p>そうした時に、次にどうすればいいのか悩むのがPromiseのテストの書き方です。</p>
</div>
<div class="paragraph">
<p>ここではまず、 <a href="http://visionmedia.github.io/mocha/">Mocha</a>を使った基本的なPromiseのテストの書き方について学んでいきましょう。</p>
</div>
<div class="paragraph">
<p>また、この章でのテストコードはNode.js環境で実行することを前提としています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
この書籍中に出てくるサンプルコードはそれぞれテストも書かれています。
テストコードは <a href="https://github.com/azu/promises-book">azu/promises-book</a> から参照できます。
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_mocha">3.1.1. Mochaとは</h4>
<div class="paragraph">
<p>ここでは、 <a href="http://visionmedia.github.io/mocha/">Mocha</a>自体については詳しく解説しませんが、
MochaはNode.js製のテストフレームワークツールです。</p>
</div>
<div class="paragraph">
<p>MochaはBDD,TDD,exportsのどれかのスタイルを選択でき、テストに使うアサーションメソッドも任意のライブラリと組み合わせて利用します。
つまり、Mocha自体はテスト実行時の枠だけを提供しており、他は利用者が選択するというものになっています。</p>
</div>
<div class="paragraph">
<p>Mochaを選んだ理由としては、以下の点で選択しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>著名なテストフレームワークであること</p>
</li>
<li>
<p>Node.jsとブラウザ どちらのテストもサポートしている</p>
</li>
<li>
<p>"Promiseのテスト"をサポートしている</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最後の<em>"Promiseのテスト"をサポートしている</em>とはどういうことなのかについては後ほど解説します。</p>
</div>
<div class="paragraph">
<p>また、アサーションライブラリには、 <a href="https://github.com/twada/power-assert">power-assert</a>を利用しますが、
アサーション自体はNode.jsの <code>assert</code> モジュールと全く同じであるため、今回はあまり気にしなくても問題ありません。</p>
</div>
<div class="paragraph">
<p>まずは、コールバック関数のテストと同じような形でテストを書いてみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="__11">3.1.2. コールバックスタイルのテスト</h4>
<div class="paragraph">
<p><a href="#promise-is-always-async">コラム: Promiseは常に非同期?</a>で確認したように、
Promiseでは <code>then</code> で登録した関数が呼ばれるタイミングは常に非同期となります。</p>
</div>
<div class="paragraph">
<p>まずはコールバックスタイルと同じようにPromiseのテストを書いてみましょう。</p>
</div>
<div class="listingblock">
<div class="title">basic-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">power-assert</span><span class="delimiter">&quot;</span></span>);
describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">Basic Test</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    context(<span class="string"><span class="delimiter">&quot;</span><span class="content">When Callback(high-order function)</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
            setTimeout(<span class="keyword">function</span> () {
                assert(<span class="predefined-constant">true</span>);
                done();
            }, <span class="integer">0</span>);
        });
    });
    context(<span class="string"><span class="delimiter">&quot;</span><span class="content">When promise object</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
            <span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);
            <span class="comment">// このテストコードはある欠陥があります</span>
            promise.then(<span class="keyword">function</span> (value) {
                assert(value === <span class="integer">1</span>);
                done();
            });
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mochaは <code>it</code> の仮引数に <code>done</code> という感じで指定してあげると、
<code>done()</code> が呼ばれるまでテストケースが終了しなくなることで非同期のテストをサポートしています。</p>
</div>
<div class="paragraph">
<p>Mochaでの非同期テストは以下のような流れになっています。</p>
</div>
<div id="callback-style-test" class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <i class="conum" data-value="1"></i><b>(1)</b>
    setTimeout(<span class="keyword">function</span> () {
        assert(<span class="predefined-constant">true</span>);
        done();<i class="conum" data-value="2"></i><b>(2)</b>
    }, <span class="integer">0</span>);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>非同期処理のコールバックを指定</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>done</code> を呼ぶことでテストの終了を宣言</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>よく見かける形の書き方ですね。</p>
</div>
</div>
<div class="sect3">
<h4 id="done-promise-test">3.1.3. <code>done</code> を使ったPromiseのテスト</h4>
<div class="paragraph">
<p>次に、Promiseのテストの方を見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);<i class="conum" data-value="1"></i><b>(1)</b>
    promise.then(<span class="keyword">function</span> (value) {
        assert(value === <span class="integer">1</span>);
        done();<i class="conum" data-value="2"></i><b>(2)</b>
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Fulfilled</code> となるpromiseオブジェクトを作成</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>done</code> を呼ぶことでテストの終了を宣言</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#Promise.resolve"><code>Promise.resolve</code></a> はpromiseオブジェクトを返しますが、
そのpromiseオブジェクトはFulFilledの状態になります。
その結果として <code>.then</code> で登録したコールバック関数が呼び出されます。</p>
</div>
<div class="paragraph">
<p><a href="#promise-is-always-async">コラム: Promiseは常に非同期?</a> でも出てきたように、
promiseオブジェクトは常に非同期で処理されるため、テストも非同期に対応した書き方が必要となります。</p>
</div>
<div class="paragraph">
<p>しかし、先ほどのテストコードでは <code>assert</code> が失敗した場合に問題が発生します。</p>
</div>
<div id="promise-assert-fail" class="listingblock">
<div class="title">間違ったテストの書き方</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <span class="keyword">var</span> promise = Promise.resolve();
    promise.then(<span class="keyword">function</span> (value) {
        assert(<span class="predefined-constant">false</span>);<span class="comment">// =&gt; throw AssertionError</span>
        done();
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このテストは <code>assert</code> が失敗しているため、「テストは失敗する」と思うかもしれませんが、
実際にはテストが終わることがなくタイムアウトします。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test-timeout.png" alt="promise test timeout">
</div>
<div class="title">Figure 7. テストが終わることがないためタイムアウトするまでそこで止まる</div>
</div>
<div class="paragraph">
<p><code>assert</code> が失敗した場合は通常はエラーをthrowし、
テストフレームワークがそれをキャッチすることで、テストが失敗したと判断します。</p>
</div>
<div class="paragraph">
<p>しかし、Promiseの場合は <code>.then</code> の中で行われた処理でエラーが発生しても、
Promiseがそれをキャッチしてしまい、テストフレームワークまでエラーがthrowされません。</p>
</div>
<div class="paragraph">
<p><a href="#promise-assert-fail"><code>assert</code> が失敗してる例</a>を改善して、
<code>assert</code> が失敗した場合にちゃんとテストが失敗となるようにしてみましょう。</p>
</div>
<div id="promise-assert-fail-fixed" class="listingblock">
<div class="title">ちゃんとテストが失敗する例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should use `done` for test?</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
    <span class="keyword">var</span> promise = Promise.resolve();
    promise.then(<span class="keyword">function</span> (value) {
        assert(<span class="predefined-constant">false</span>);
    }).then(done, done);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>ちゃんとテストが失敗する例では、必ず <code>done</code> が呼ばれるようにするため、
最後に <code>.then(done, done);</code> を追加しています。</p>
</div>
<div class="paragraph">
<p><code>assert</code> がパスした場合は単純に <code>done()</code> が呼ばれ、<code>assert</code> が失敗した場合は <code>done(error)</code> が呼ばれます。</p>
</div>
<div class="paragraph">
<p>これでようやく<a href="#callback-style-test">コールバックスタイルのテスト</a>と同等のPromiseのテストを書くことができました。</p>
</div>
<div class="paragraph">
<p>しかし、<code>assert</code> が失敗した時のために <code>.then(done, done);</code> というものを付ける必要があります。
Promiseのテストを書くときにつけ忘れてしまうと終わらないテストが出来上がってしまう場合があることに気をつけましょう。</p>
</div>
<div class="paragraph">
<p>次に、最初にmochaを使う理由に上げた"Promisesのテスト"をサポートしているという事がどういう機能なのかを学んでいきましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mocha-promise">3.2. MochaのPromiseサポート</h3>
<div class="paragraph">
<p>Mochaがサポートしてる"Promiseのテスト"とは何かについて学んでいきましょう。</p>
</div>
<div class="paragraph">
<p>公式サイトの <a href="http://visionmedia.github.io/mocha/#asynchronous-code">Asynchronous code</a>にもその概要が書かれています。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Alternately, instead of using the done() callback, you can return a promise. This is useful if the APIs you are testing return promises instead of taking callbacks:</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Promiseのテストの場合はコールバックとして <code>done()</code> を呼ぶ代わりに、promiseオブジェクトをreturnすることが出来ると書いてあります。</p>
</div>
<div class="paragraph">
<p>では、実際にどのように書くかの例を見て行きたいと思います。</p>
</div>
<div id="mocha-promise-test.js" class="listingblock">
<div class="title">mocha-promise-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">power-assert</span><span class="delimiter">&quot;</span></span>);
describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">Promise Test</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should return a promise object</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        <span class="keyword">var</span> promise = Promise.resolve(<span class="integer">1</span>);
        <span class="keyword">return</span> promise.then(<span class="keyword">function</span> (value) {
            assert(value === <span class="integer">1</span>);
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#promise-assert-fail-fixed">先ほどの <code>done</code> を使った例</a>をMochaのPromiseテストの形式に変更しました。</p>
</div>
<div class="paragraph">
<p>変更点としては以下の2つとなっています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> そのものを取り除いた</p>
</li>
<li>
<p>promiseオブジェクトを返すようにした</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>この書き方をした場合、<code>assert</code> が失敗した場合はもちろんテストが失敗します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should be fail</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> Promise.resolve().then(<span class="keyword">function</span> () {
        assert(<span class="predefined-constant">false</span>);<span class="comment">// =&gt; テストが失敗する</span>
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>これにより <code>.then(done, done);</code> というような本質的にはテストとは関係ない記述を省くことが出来るようになりました。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://efcl.info/2014/0314/res3708/">MochaがPromisesのテストをサポートしました | Web scratch</a> という記事でも
MochaのPromiseサポートについて書かれています。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="__12">3.2.1. 意図しないテスト結果</h4>
<div class="paragraph">
<p>MochaがPromiseのテストをサポートしているため、この書き方で良いと思われるかもしれません。
しかし、この書き方にも意図しない結果になる例外が存在します。</p>
</div>
<div class="paragraph">
<p>例えば、以下はある条件だとRejectedなpromiseオブジェクトを返す <code>mayBeRejected()</code> のテストコードです。</p>
</div>
<div id="mocha-rejected-promise-test" class="listingblock">
<div class="title">エラーオブジェクトをテストしたい</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>(){ <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>));
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">is bad pattern</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> mayBeRejected().<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>この関数が返すpromiseオブジェクトをテストしたい</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>このテストの目的とは以下のようになっています。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>mayBeRejected()</code> が返すpromiseオブジェクトがFulFilledとなった場合</dt>
<dd>
<p>テストを失敗させる</p>
</dd>
<dt class="hdlist1"><code>mayBeRejected()</code> が返すpromiseオブジェクトがRejectedとなった場合</dt>
<dd>
<p><code>assert</code> でErrorオブジェクトをチェックする</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>上記のテストコードでは、Rejectedとなって <code>onRejected</code> に登録された関数が呼ばれるためテストはパスしますね。</p>
</div>
<div class="paragraph">
<p>このテストで問題になるのは <code>mayBeRejected()</code> で返されたpromiseオブジェクトが
<strong>FulFilledとなった場合</strong>に、必ずテストがパスしてしまうという問題が発生します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>(){ <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">is bad pattern</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> mayBeRejected().<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>返されるpromiseオブジェクトはFulFilledとなる</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この場合、<code>catch</code> で登録した <code>onRejected</code> の関数はそもそも呼ばれないため、
<code>assert</code> がひとつも呼ばれることなくテストが必ずパスしてしまいます。</p>
</div>
<div class="paragraph">
<p>これを解消しようとして、<code>.catch</code> の前に <code>.then</code> を入れて、
<code>.then</code> が呼ばれたらテストを失敗にしたいと考えるかもしれません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">failTest</span>() { <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">Expected promise to be rejected but it was fulfilled</span><span class="delimiter">&quot;</span></span>);
}
<span class="keyword">function</span> <span class="function">mayBeRejected</span>(){
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">should bad pattern</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">return</span> mayBeRejected().then(failTest).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert.deepEqual(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>throwすることでテストを失敗にしたい</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>しかし、この書き方だと<a href="#then-or-catch">then or catch?</a>で紹介したように、
<code>failTest</code> で投げられたエラーが <code>catch</code> されてしまいます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch2_HowToWrite/img/then_catch.png" alt="Then Catch flow">
</div>
<div class="title">Figure 8. Then Catch flow</div>
</div>
<div class="paragraph">
<p><code>then</code> &#8594; <code>catch</code> となり、<code>catch</code> に渡ってくるErrorオブジェクトは <code>AssertionError</code> となり、
意図したものとは違うものが渡ってきてしまいます。</p>
</div>
<div class="paragraph">
<p>つまり、onRejectedになること<strong>だけ</strong>を期待して書かれたテストは、onFulfilledの状態になってしまうと
常にテストがパスしてしまうという問題を持っていることが分かります。</p>
</div>
</div>
<div class="sect3">
<h4 id="__13">3.2.2. 両状態を明示して意図しないテストを改善</h4>
<div class="paragraph">
<p><a href="#mocha-rejected-promise-test">上記のエラーオブジェクトのテスト</a>を書く場合、
どのようにすれば意図せず通ってしまうテストを無くす事が出来るでしょうか?</p>
</div>
<div class="paragraph">
<p>一番単純な方法としては、以下のようにそれぞれの状態の場合にどうなるのかをテストコードに書く方法です。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">FulFilledとなった場合</dt>
<dd>
<p>意図した通りテストが失敗する</p>
</dd>
<dt class="hdlist1">Rejectedとなった場合</dt>
<dd>
<p><code>assert</code> でテストを行える</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>つまり、Fulfilled、Rejected 両方の状態について、テストがどうなってほしいかを明示する必要があるわけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">mayBeRejected</span>() {
    <span class="keyword">return</span> Promise.resolve();
}
it(<span class="string"><span class="delimiter">&quot;</span><span class="content">catch -&gt; then</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="comment">// FulFilledとなった場合はテストは失敗する</span>
    <span class="keyword">return</span> mayBeRejected().then(failTest, <span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">&quot;</span><span class="content">woo</span><span class="delimiter">&quot;</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように書くことで、FulFilledとなった場合は失敗するテストコードを書くことができます。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test.png" alt="Promise onRejected test">
</div>
<div class="title">Figure 9. Promise onRejected test</div>
</div>
<div class="paragraph">
<p><a href="#then-or-catch">then or catch?</a>の時は、エラーの見逃しを避けるため、
<code>.then(onFulfilled, onRejected)</code> の第二引数ではなく、<code>then</code> &#8594; <code>catch</code> と分けることを推奨していました。</p>
</div>
<div class="paragraph">
<p>しかし、テストの場合はPromiseの強力なエラーハンドリングが逆にテストの邪魔をしてしまいます。
そのため <code>.then(failTest, onRejected)</code> と書くことで、どちらの状態になるのかを明示してテストを書くことができました。</p>
</div>
</div>
<div class="sect3">
<h4 id="__14">3.2.3. まとめ</h4>
<div class="paragraph">
<p>MochaのPromiseサポートについてと意図しない挙動となる場合について紹介しました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通常のコードは <code>then</code> &#8594; <code>catch</code> と分けた方がよい</p>
<div class="ulist">
<ul>
<li>
<p>エラーハンドリングのため。<a href="#then-or-catch">then or catch?</a>を参照</p>
</li>
</ul>
</div>
</li>
<li>
<p>テストコードは <code>then</code> にまとめた方がよい</p>
<div class="ulist">
<ul>
<li>
<p>アサーションエラーがテストフレームワークに届くようにするため。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>.then(onFulfilled, onRejected)</code> を使うことで、
promiseオブジェクトがFulfilled、Rejectedどちらの状態になるかを明示してテストする必要があります。</p>
</div>
<div class="paragraph">
<p>しかし、Rejectedのテストであることを明示するために、以下のように書くのはあまり直感的ではないと思います。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(failTest, <span class="keyword">function</span>(error){
    <span class="comment">// assertでerrorをテストする</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>次は、Promiseのテストを手助けするヘルパー関数を定義して、
もう少し分かりやすいテストを書くにはどうするべきかについて見て行きましょう。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="controllable-tests">3.3. 意図したテストを書くには</h3>
<div class="paragraph">
<p>ここでいう意図したテストとは以下のような定義で進めます。</p>
</div>
<div class="paragraph">
<p>あるpromiseオブジェクトをテスト対象として</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fulfilledされることを期待したテストを書いた時</p>
<div class="ulist">
<ul>
<li>
<p>Rejectedとなった場合は<strong>Fail</strong></p>
</li>
<li>
<p>assertionの結果が一致しなかった場合は<strong>Fail</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p>Rejectedされることを期待したテストを書いた時</p>
<div class="ulist">
<ul>
<li>
<p>Fulfilledとなった場合は<strong>Fail</strong></p>
</li>
<li>
<p>assertionの結果が一致しなかった場合は<strong>Fail</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>上記のケース(Fail)に該当しなければテストがパスするという事ですね。</p>
</div>
<div class="paragraph">
<p>つまり、ひとつのテストケースにおいて以下のことを書く必要があります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fulfilled or Rejected どちらを期待するか</p>
</li>
<li>
<p>assertionで渡された値のチェック</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>先ほどの <code>.then</code> を使ったコードはRejectedを期待したテストとなっていますね。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(failTest, <span class="keyword">function</span>(error){
    <span class="comment">// assertでerrorをテストする</span>
    assert(error <span class="keyword">instanceof</span> Error);
});</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="__15">3.3.1. どちらの状態になるかを明示する</h4>
<div class="paragraph">
<p>意図したテストにするためには、<a href="#promise-states">promiseの状態</a>が
Fulfilled or Rejected どちらの状態になって欲しいかを明示する必要があります。</p>
</div>
<div class="paragraph">
<p>しかし、<code>.then</code> だと引数は省略可能なので、テストが落ちる条件を入れ忘れる可能性もあります。</p>
</div>
<div class="paragraph">
<p>そこで、promiseオブジェクトに期待する状態を明示できるヘルパー関数を定義してみましょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ライブラリ化したものが <a href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</a> にありますが、
今回はその場で簡単に定義して進めます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>まずは、先ほどの <code>.then</code> の例を元にonRejectedを期待してテスト出来る
<code>shouldRejected</code> というヘルパー関数を作ってみたいと思います。</p>
</div>
<div id="shouldRejected-test.js" class="listingblock">
<div class="title">shouldRejected-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">'</span><span class="content">power-assert</span><span class="delimiter">'</span></span>);
<span class="keyword">function</span> <span class="function">shouldRejected</span>(promise) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">'</span><span class="content">catch</span><span class="delimiter">'</span></span>: <span class="keyword">function</span> (fn) {
            <span class="keyword">return</span> promise.then(<span class="keyword">function</span> () {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Expected promise to be rejected but it was fulfilled</span><span class="delimiter">'</span></span>);
            }, <span class="keyword">function</span> (reason) {
                fn.call(promise, reason);
            });
        }
    };
}
it(<span class="string"><span class="delimiter">'</span><span class="content">should be rejected</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">var</span> promise = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>));
    <span class="keyword">return</span> shouldRejected(promise).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
        assert(error.message === <span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> にpromiseオブジェクトを渡すと、<code>catch</code> というメソッドをもつオブジェクトを返します。</p>
</div>
<div class="paragraph">
<p>この <code>catch</code> にはonRejectedで書くものと全く同じ使い方ができるので、
<code>catch</code> の中にassertionによるテストを書けるようになっています。</p>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> で囲む以外は、通常のpromiseの処理と似た感じになるので以下のようになります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>shouldRejected</code> にテスト対象のpromiseオブジェクトを渡す</p>
</li>
<li>
<p>返ってきたオブジェクトの <code>catch</code> メソッドでonRejectedの処理を書く</p>
</li>
<li>
<p>onRejectedにassertionによるテストを書く</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> を使った場合、Fulfilledが呼ばれるとエラーをthrowしてテストが失敗するようになっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(failTest, <span class="keyword">function</span>(error){
    assert(error.message === <span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>);
});
<span class="comment">// == ほぼ同様の意味</span>
shouldRejected(promise).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    assert(error.message === <span class="string"><span class="delimiter">'</span><span class="content">human error</span><span class="delimiter">'</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>shouldRejected</code> のようなヘルパー関数を使うことで、テストコードが少し直感的になりましたね。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch3_Testing/img/promise-test.png" alt="Promise onRejected test">
</div>
<div class="title">Figure 10. Promise onRejected test</div>
</div>
<div class="paragraph">
<p>同様に、promiseオブジェクトがFulfilledになることを期待する <code>shouldFulfilled</code> も書いてみましょう。</p>
</div>
<div id="shouldFulfilled-test.js" class="listingblock">
<div class="title">shouldFulfilled-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">'</span><span class="content">power-assert</span><span class="delimiter">'</span></span>);
<span class="keyword">function</span> <span class="function">shouldFulfilled</span>(promise) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">'</span><span class="content">then</span><span class="delimiter">'</span></span>: <span class="keyword">function</span> (fn) {
            <span class="keyword">return</span> promise.then(<span class="keyword">function</span> (value) {
                fn.call(promise, value);
            }, <span class="keyword">function</span> (reason) {
                <span class="keyword">throw</span> reason;
            });
        }
    };
}
it(<span class="string"><span class="delimiter">'</span><span class="content">should be fulfilled</span><span class="delimiter">'</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">var</span> promise = Promise.resolve(<span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>);
    <span class="keyword">return</span> shouldFulfilled(promise).then(<span class="keyword">function</span> (value) {
        assert(value === <span class="string"><span class="delimiter">'</span><span class="content">value</span><span class="delimiter">'</span></span>);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#shouldRejected-test.js">shouldRejected-test.js</a>と基本は同じで、返すオブジェクトの <code>catch</code> が <code>then</code> になって中身が逆転しただけですね。</p>
</div>
</div>
<div class="sect3">
<h4 id="__16">3.3.2. まとめ</h4>
<div class="paragraph">
<p>Promiseで意図したテストを書くためにはどうするか、またそれを補助するヘルパー関数について学びました。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>今回書いた <code>shouldFulfilled</code> と <code>shouldRejected</code> はライブラリとして利用できるようになっています。</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/azu/promise-test-helper">azu/promise-test-helper</a> からダウンロードすることが出来ます。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>また、今回のヘルパー関数は<a href="#mocha-promise">MochaのPromiseサポート</a>を前提とした書き方なので、
<a href="#done-promise-test"><code>done</code> を使ったテスト</a>では利用しにくいと思います。</p>
</div>
<div class="paragraph">
<p>テストフレームワークのPromiseサポートを使うか、<code>done</code> のようにコールバックスタイルのテストを使うかは、
人それぞれのスタイルの問題であるためそこまではっきりした優劣はないと思います。</p>
</div>
<div class="paragraph">
<p>例えば、 <a href="http://coffeescript.org/">CoffeeScript</a>でテストを書いたりすると、
CoffeeScriptには暗黙のreturnがあるので、<code>done</code> を使ったほうが分かりやすいかもしれません。</p>
</div>
<div class="paragraph">
<p>Promiseのテストは普通に非同期関数のテスト以上に落とし穴があるため、
どのスタイルを取るかは自由ですが、一貫性を持った書き方をすることが大切だと言えます。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chapter4-advanced-promise">4. Chapter.4 - Advanced</h2>
<div class="sectionbody">
<div class="paragraph">
<p>この章では、これまでに学んだことの応用や発展した内容について学んでいきます。</p>
</div>
<div class="sect2">
<h3 id="promise-library">4.1. Promiseのライブラリ</h3>
<div class="paragraph">
<p>このセクションでは、ブラウザが実装しているPromiseではなく、サードパーティにより作られた
Promise互換のライブラリについて紹介していきたいと思います。</p>
</div>
<div class="sect3">
<h4 id="__17">4.1.1. なぜライブラリが必要か?</h4>
<div class="paragraph">
<p>なぜライブラリが必要か?という疑問に関する多くの答えとしては、
その実行環境で「<a href="#es6-promises">ES6 Promises</a>が実装されていないから」というのがまず出てくるでしょう。</p>
</div>
<div class="iframe-wrapper" style="width: 100%; height: 350px; overflow: auto; -webkit-overflow-scrolling: touch;">
<iframe src="http://caniuse.com/promises/embed/agents=desktop" width="100%" height="350px"></iframe>
</div>
<div class="paragraph">
<p>Promiseのライブラリを探すときに、一つ目印になる言葉として<a href="#promises-aplus">Promises/A+互換</a>があります。</p>
</div>
<div class="paragraph">
<p><a href="#promises-aplus">Promises/A+</a>というのは<a href="#es6-promises">ES6 Promises</a>の前身となったもので、
Promiseの <code>then</code> について取り決めたコミュニティベースの仕様です。</p>
</div>
<div class="paragraph">
<p>Promises/A+互換と書かれていた場合は <code>then</code> についての動作は互換性があり、
多くの場合はそれに加えて <code>Promise.all</code> や <code>catch</code> 等と同様の機能が実装されています。</p>
</div>
<div class="paragraph">
<p>しかし、Promises/A+は <code>Promise#then</code> についてのみの仕様となっているため、
他の機能は実装されていても名前が異なる場合があります。</p>
</div>
<div class="paragraph">
<p>また、<code>then</code> というメソッドに互換性があるという事は、<a href="#Thenable">Thenable</a>であるということなので、
<a href="#Promise.resolve">Promise.resolve</a>を使い、ES6のPromiseで定められたpromiseオブジェクトに変換することが出来ます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ES6のPromiseで定められたpromiseオブジェクトというのは、
<code>catch</code> というメソッドが使えたり、<code>Promise.all</code> で扱う際に問題が起こらないということです。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_polyfill">4.1.2. Polyfillとライブラリ</h4>
<div class="paragraph">
<p>ここでは、大きくわけて2種類のライブラリを紹介したいと思います。</p>
</div>
<div class="paragraph">
<p>一つはPolyfillと呼ばれる種類のライブラリで、
もう一つは、<a href="#promises-aplus">Promises/A+互換</a>に加えて、独自の拡張をもったライブラリです。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Promiseのライブラリは星の数ほどあるので、ここで紹介するのは極々一部です。
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="promise-polyfill">Polyfill</h5>
<div class="paragraph">
<p>Polyfillライブラリは読み込む事で、IE10等まだPromiseが実装されていないブラウザ等でも、
Promiseと同等の機能を同じメソッド名で提供してくれるライブラリのことです。</p>
</div>
<div class="paragraph">
<p>つまり、Polyfillを読みこめばこの書籍で紹介しているコードは、
Promiseがサポートされてない環境でも実行出来るようになります。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/jakearchibald/es6-promise">jakearchibald/es6-promise</a></dt>
<dd>
<p>ES6 Promisesと互換性を持ったPolyfillライブラリです。
<a href="https://github.com/tildeio/rsvp.js">RSVP.js</a> という Promises/A+互換ライブラリがベースとなっており、
これのサブセットとしてES6 PromisesのAPIだけが実装されているライブラリです。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/yahoo/ypromise">yahoo/ypromise</a></dt>
<dd>
<p><a href="http://yuilibrary.com/">YUI</a> の一部としても利用されているES6 Promisesと互換性を持ったPolyfillライブラリです。
この書籍ではこのPolyfillを読み込み、サンプルコードを動かしています。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_promise_3">Promise拡張ライブラリ</h5>
<div class="paragraph">
<p>Promiseを仕様どおりに実装したものに加えて独自のメソッド等を提供してくれるライブラリです。</p>
</div>
<div class="paragraph">
<p>Promise拡張ライブラリは本当に沢山ありますが、以下の2つの著名なライブラリを紹介します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/kriskowal/q">kriskowal/q</a></dt>
<dd>
<p><code>Q</code> と呼ばれるPromisesやDeferredsを実装したライブラリです。
2009年から開発されており、Node.js向けのファイルIOのAPIを提供する <a href="https://github.com/kriskowal/q-io">Q-IO</a> 等、
多くの状況で使える機能が用意されているライブラリです。</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/petkaantonov/bluebird">petkaantonov/bluebird</a></dt>
<dd>
<p>Promise互換に加えて、キャンセル出来るPromiseや進行度を取得出来るPromise、エラーハンドリングの拡張検出等、
多くの拡張を持っており、またパフォーマンスにも気を配った実装がされているライブラリです。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Q と Bluebird どちらのライブラリもブラウザでも動作する他、APIリファレンスが充実しているのも特徴的です。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kriskowal/q/wiki/API-Reference">API Reference · kriskowal/q Wiki</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>QのドキュメントにはjQueryが持つDeferredの仕組みとどのように違うのか、移行する場合の対応メソッドについても
<a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery</a> にまとめられています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/petkaantonov/bluebird/blob/master/API.md">bluebird/API.md at master · petkaantonov/bluebird</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>BluebirdではPromiseを使った豊富な実装例に加えて、エラーが起きた時の対処法や
<a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns">Promiseのアンチパターン</a> について書かれています。</p>
</div>
<div class="paragraph">
<p>どちらのドキュメントも優れているため、このライブラリを使ってない場合でも読んでおくと参考になる事が多いと思います。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__18">4.1.3. まとめ</h4>
<div class="paragraph">
<p>このセクションではPromiseのライブラリとしてPolyfillと拡張ライブラリを紹介しました。</p>
</div>
<div class="paragraph">
<p>Promiseのライブラリは多種多様であるため、どれを使用するかは好みの問題といえるでしょう。</p>
</div>
<div class="paragraph">
<p>しかし、PromiseはPromises/A+ または ES6 Promisesという共通のインターフェースを持っているため、
そのライブラリで書かれているコードや独自の拡張などは、他のライブラリを利用している時でも参考になるケースは多いでしょう。</p>
</div>
<div class="paragraph">
<p>そのようなPromiseの共通の概念を学び、応用できるようになるのがこの書籍の目的の一つです。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resolve-thenable">4.2. Promise.resolveとThenable</h3>
<div class="paragraph">
<p><a href="#ch2-promise-resolve">第二章のPromise.resolve</a>にて、<code>Promise.resolve</code> の大きな特徴の一つとしてthenableなオブジェクトを変換する機能について紹介しました。</p>
</div>
<div class="paragraph">
<p>このセクションでは、thenableなオブジェクトからpromiseオブジェクトに変換してどのように利用するかについて学びたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_web_notifications_thenable">4.2.1. Web Notificationsをthenableにする</h4>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/ja/docs/Web/API/notification">Web Notifications</a>という
デスクトップ通知を行うAPIを例に考えてみます。</p>
</div>
<div class="paragraph">
<p>Web Notifications APIについて詳しくは以下を参照して下さい。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/ja/docs/WebAPI/Using_Web_Notifications">Web Notifications の使用 - WebAPI | MDN</a></p>
</li>
<li>
<p><a href="http://caniuse.com/notifications">Can I use Web Notifications</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Web Notifications APIについて簡単に解説すると、以下のように <code>new Notification</code> をすることで通知メッセージが表示できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Notification(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>しかし、通知を行うためには、<code>new Notification</code> をする前にユーザーに許可を取る必要があります。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/notification-dialog.png" alt="Notificationの許可ダイアログ">
</div>
<div class="title">Figure 11. Notificationの許可ダイアログ</div>
</div>
<div class="paragraph">
<p>この許可ダイアログで選択した結果は、<code>Notification.permission</code> に入りますが、
値は許可("granted")か不許可("denied")の2種類です。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Notificationのダイアログの選択肢は、
Firefoxだと許可、不許可に加えて <em>永続</em> か <em>セッション限り</em> の組み合わせがありますが、値自体は同じです。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>許可ダイアログは <code>Notification.requestPermission()</code> を実行すると表示され、
ユーザーが選択した結果がコールバック関数の <code>status</code> に渡されます。</p>
</div>
<div class="paragraph">
<p>コールバックを受け付けることから分かるように、この許可、不許可は非同期的に行われます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Notification.requestPermission(<span class="keyword">function</span> (status) {
    <span class="comment">// statusに&quot;granted&quot; or &quot;denied&quot;が入る</span>
    console.log(status);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>通知を行うまでの流れをまとめると以下のようになります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ユーザーに通知の許可を受け付ける非同期処理がある</p>
</li>
<li>
<p>許可がある場合は <code>new Notification</code> で通知を表示できる</p>
<div class="ulist">
<ul>
<li>
<p>既に許可済みのケース</p>
</li>
<li>
<p>その場で許可を貰うケース</p>
</li>
</ul>
</div>
</li>
<li>
<p>許可がない場合は何もしない</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>いくつかのパターンが出ますが、最終的には許可か不許可になるので、以下の2パターンにまとめることが出来ます。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">許可時("granted")</dt>
<dd>
<p><code>new Notification</code> で通知を作成</p>
</dd>
<dt class="hdlist1">不許可時("denied")</dt>
<dd>
<p>何もしない</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>この2パターンはどこかで見たことがありますね。
そう、PromiseのFulfilled または Rejected となった時の動作で書くことが出来そうな気がします。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">resolve(成功)した時 == 許可時("granted")</dt>
<dd>
<p><code>onFulfilled</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">reject(失敗)した時 == 不許可時("denied")</dt>
<dd>
<p><code>onRejected</code>  が呼ばれる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Promiseで書けそうな目処が見えた所で、まずはコールバックスタイルで書いてみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notification">4.2.2. Web Notification ラッパー</h4>
<div class="paragraph">
<p>まずは先ほどのWeb Notification APIのラッパー関数をコールバックスタイルで書くと次のように書くことが出来ます。</p>
</div>
<div id="notification-callback.js" class="listingblock executable">
<div class="title">notification-callback.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (Notification &amp;&amp; Notification.permission === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
        <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Notification.requestPermission) {
        Notification.requestPermission(<span class="keyword">function</span> (status) {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">user denied</span><span class="delimiter">'</span></span>));
            }
        });
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">doesn</span><span class="char">\'</span><span class="content">t support Notification API</span><span class="delimiter">'</span></span>));
    }
}
<span class="comment">// 実行例</span>
<span class="comment">// 第二引数は `Notification` に渡すオプションオブジェクト</span>
notifyMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>, {}, <span class="keyword">function</span> (error, notification) {
    <span class="keyword">if</span>(error){
        <span class="keyword">return</span> console.error(error);
    }
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>コールバックスタイルでは、許可がない場合は <code>error</code> に値が入り、
許可がある場合は通知が行われて <code>notification</code> に値が入ってくるという感じにしました。</p>
</div>
<div class="listingblock">
<div class="title">コールバック関数はエラーとnotificationオブジェクトを受け取る</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">callback</span>(error, notification){

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、このコールバックスタイルの関数をPromiseとして使える関数を書いてみたいと思います。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notification_as_promise">4.2.3. Web Notification as Promise</h4>
<div class="paragraph">
<p>先ほどのコールバックスタイルの <code>notifyMessage</code> とは別に、
promiseオブジェクトを返す <code>notifyMessageAsPromise</code> を定義してみます。</p>
</div>
<div id="notification-as-promise.js" class="listingblock executable">
<div class="title">notification-as-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (Notification &amp;&amp; Notification.permission === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
        <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Notification.requestPermission) {
        Notification.requestPermission(<span class="keyword">function</span> (status) {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">user denied</span><span class="delimiter">'</span></span>));
            }
        });
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">doesn</span><span class="char">\'</span><span class="content">t support Notification API</span><span class="delimiter">'</span></span>));
    }
}
<span class="keyword">function</span> <span class="function">notifyMessageAsPromise</span>(message, options) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        notifyMessage(message, options, <span class="keyword">function</span> (error, notification) {
            <span class="keyword">if</span> (error) {
                reject(error);
            } <span class="keyword">else</span> {
                resolve(notification);
            }
        });
    });
}
<span class="comment">// 実行例</span>
notifyMessageAsPromise(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hi!</span><span class="delimiter">&quot;</span></span>).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>上記の実行例では、許可がある場合 <code>"Hi!"</code> という通知が表示されます。</p>
</div>
<div class="paragraph">
<p>許可されている場合は <code>.then</code> が呼ばれ、
不許可となった場合は <code>.catch</code> が呼ばれます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ブラウザはWeb Notifications APIの状態をサイトごとに許可状態を記憶できるため、
実際には以下の4つのパターンが存在します。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">既に許可されている</dt>
<dd>
<p><code>.then</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">許可ダイアログがでて許可された</dt>
<dd>
<p><code>.then</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">既に不許可となっている</dt>
<dd>
<p><code>.catch</code> が呼ばれる</p>
</dd>
<dt class="hdlist1">許可ダイアログが出て不許可となった</dt>
<dd>
<p><code>.catch</code> が呼ばれる</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>つまり、Web Notifications APIをそのまま扱うと、4つのパターンについて書かないといけませんが、
それを2パターンにできるラッパーを書くと扱いやすくなります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上記の<a href="#notification-as-promise.js">notification-as-promise.js</a>は、とても便利そうですが実際に使うときには
<strong>Promiseをサポートしてない環境では使えない</strong>という問題があります。</p>
</div>
<div class="paragraph">
<p><a href="#notification-as-promise.js">notification-as-promise.js</a>のようなPromiseスタイルで使えるライブラリを作る場合、
ライブラリ作成者には以下の選択肢があると思います。</p>
</div>
<div id="promise-library-choice" class="dlist">
<dl>
<dt class="hdlist1">Promiseが使える環境を前提とする</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>利用者に <code>Promise</code> があることを保証してもらう</p>
</li>
<li>
<p>Promiseをサポートしてない環境では動かないことにする</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">ライブラリ自体に <code>Promise</code> の実装を入れてしまう</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>ライブラリ自体にPromiseの実装を取り込む</p>
</li>
<li>
<p>例) <a href="https://github.com/mozilla/localForage">localForage</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">コールバックでも <code>Promise</code> でも使えるようにする</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>利用者がどちらを使うかを選択出来るようにする</p>
</li>
<li>
<p>Thenableを返せるようにする</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p><a href="#notification-as-promise.js">notification-as-promise.js</a>は <code>Promise</code> があることを前提としたような書き方です。</p>
</div>
<div class="paragraph">
<p>本題に戻り<a href="#Thenable">Thenable</a>はここでいう<strong>コールバックでも <code>Promise</code> でも使えるようにする</strong>という事を
実現するのに役立つ概念です。</p>
</div>
</div>
<div class="sect3">
<h4 id="_web_notifications_as_thenable">4.2.4. Web Notifications As Thenable</h4>
<div class="paragraph">
<p><a href="#Thenable">thenable</a>というのは <code>.then</code> というメソッドを持ってるオブジェクトのことを言いましたね。
次は<a href="#notification-callback.js">notification-callback.js</a>に <code>thenable</code> を返すメソッドを追加してみましょう。</p>
</div>
<div id="notification-thenable.js" class="listingblock executable">
<div class="title">notification-thenable.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">notifyMessage</span>(message, options, callback) {
    <span class="keyword">if</span> (Notification &amp;&amp; Notification.permission === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
        <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
        callback(<span class="predefined-constant">null</span>, notification);
    } <span class="keyword">else</span> <span class="keyword">if</span> (Notification.requestPermission) {
        Notification.requestPermission(<span class="keyword">function</span> (status) {
            <span class="keyword">if</span> (Notification.permission !== status) {
                Notification.permission = status;
            }
            <span class="keyword">if</span> (status === <span class="string"><span class="delimiter">'</span><span class="content">granted</span><span class="delimiter">'</span></span>) {
                <span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(message, options);
                callback(<span class="predefined-constant">null</span>, notification);
            } <span class="keyword">else</span> {
                callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">user denied</span><span class="delimiter">'</span></span>));
            }
        });
    } <span class="keyword">else</span> {
        callback(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">doesn</span><span class="char">\'</span><span class="content">t support Notification API</span><span class="delimiter">'</span></span>));
    }
}
<span class="comment">// `thenable` を返す</span>
<span class="keyword">function</span> <span class="function">notifyMessageAsThenable</span>(message, options) {
    <span class="keyword">return</span> {
        <span class="key"><span class="delimiter">'</span><span class="content">then</span><span class="delimiter">'</span></span>: <span class="keyword">function</span> (resolve, reject) {
            notifyMessage(message, options, <span class="keyword">function</span> (error, notification) {
                <span class="keyword">if</span> (error) {
                    reject(error);
                } <span class="keyword">else</span> {
                    resolve(notification);
                }
            });
        }
    };
}
<span class="comment">// 実行例</span>
Promise.resolve(notifyMessageAsThenable(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#notification-thenable.js">notification-thenable.js</a> には <code>notifyMessageAsThenable</code> というそのままのメソッドを追加してみました。
返すオブジェクトには <code>then</code> というメソッドがあります。</p>
</div>
<div class="paragraph">
<p><code>then</code> メソッドの仮引数には <code>new Promise(function (resolve, reject){})</code> と同じように、
解決した時に呼ぶ <code>resolve</code> と、棄却した時に呼ぶ <code>reject</code> が渡ります。</p>
</div>
<div class="paragraph">
<p><code>then</code> メソッドがやっている中身は<a href="#notification-as-promise.js">notification-as-promise.js</a>の <code>notifyMessageAsPromise</code> と同じですね。</p>
</div>
<div class="paragraph">
<p>この <code>thenable</code> を <code>Promise.resolve(thenable)</code> を使いpromiseオブジェクトにしてから、
Promiseとして利用していることが分かりますね。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(notifyMessageAsThenable(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>)).then(<span class="keyword">function</span> (notification) {
    console.log(notification);<span class="comment">// 通知のオブジェクト</span>
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thenableを使った<a href="#notification-thenable.js">notification-thenable.js</a>とPromiseに依存した<a href="#notification-as-promise.js">notification-as-promise.js</a>は、
非常に似た使い方ができることがわかります。</p>
</div>
<div class="paragraph">
<p><a href="#notification-thenable.js">notification-thenable.js</a>には<a href="#notification-as-promise.js">notification-as-promise.js</a>と比べた時に、次のような違いがあります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ライブラリ側に <code>Promise</code> 実装そのものはでてこない</p>
<div class="ulist">
<ul>
<li>
<p>利用者が <code>Promise.resolve(thenable)</code> を使い <code>Promise</code> の実装を与える</p>
</li>
</ul>
</div>
</li>
<li>
<p>Promiseとして使う時に <code>Promise.resolve(thenable)</code> と一枚挟む必要がある</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#Thenable">Thenable</a>オブジェクトを利用することで、
既存のコールバックスタイルとPromiseスタイルの中間的な実装をすることができました。</p>
</div>
</div>
<div class="sect3">
<h4 id="__19">4.2.5. まとめ</h4>
<div class="paragraph">
<p>このセクションではThenableとは何かやThenableを <code>Promise.resolve(thenable)</code> を使って、
promiseオブジェクトとして利用する方法について学びました。</p>
</div>
<div class="paragraph">
<p>Callback&#8201;&#8212;&#8201;Thenable&#8201;&#8212;&#8201;Promise</p>
</div>
<div class="paragraph">
<p>Thenableスタイルは、コールバックスタイルとPromiseスタイルの中間的な表現で、
ライブラリが公開するAPIとしては中途半端なためあまり見かけることがないと思います。</p>
</div>
<div class="paragraph">
<p>Thenable自体は <code>Promise</code> という機能に依存してはいませんが、Promise以外からの利用方法は特にないため、
間接的にはPromiseに依存しています。</p>
</div>
<div class="paragraph">
<p>また、使うためには利用者が <code>Promise.resolve(thenable)</code> について理解している必要があるため、
ライブラリの公開APIとしては難しい部分があります。
Thenable自体は公開APIより、内部的に使われてるケースが多いでしょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>非同期処理を行うライブラリを書く際には、まずはコールバックスタイルの関数を書いて公開APIとすることをオススメします。</p>
</div>
<div class="paragraph">
<p>Node.jsのCore moduleがこの方法をとっているように、ライブラリが提供するのは基本となるコールバックスタイル関数としたほうが、
利用者がPromiseやGenerator等の好きな方法で実装ができるためです。</p>
</div>
<div class="paragraph">
<p>最初からPromiseで利用することを目的としたライブラリや、その機能がPromiseに依存している場合は、
promiseオブジェクトを返す関数を公開APIとしても問題ないと思います。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_thenable_2">Thenableの使われているところ</h5>
<div class="paragraph">
<p>では、どのような場面でThenableは使われてるのでしょうか?</p>
</div>
<div class="paragraph">
<p>恐らく、一番多く使われている所は<a href="#promise-library">Promiseのライブラリ</a>間での相互変換でしょう。</p>
</div>
<div class="paragraph">
<p>例えば、 QライブラリのPromiseのインスタンスであるQ promiseオブジェクトは、
<a href="#es6-promises">ES6 Promises</a>のpromiseオブジェクトが持っていないメソッドを持っています。
Q promiseオブジェクトには <code>promise.finally(callback)</code> や <code>promise.nodeify(callback)</code> などのメソッドが用意されてます。</p>
</div>
<div class="paragraph">
<p>ES6 PromisesのpromiseオブジェクトをQ promiseオブジェクトに変換するときに使われるのが、
まさにこのThenableです。</p>
</div>
<div class="listingblock">
<div class="title">thenableを使ってQ promiseオブジェクトにする</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> Q = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">Q</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// このpromiseオブジェクトはES6のもの</span>
<span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    resolve(<span class="integer">1</span>);
});
<span class="comment">// Q promiseオブジェクトに変換する</span>
Q(promise).then(<span class="keyword">function</span>(value){
    console.log(value);
}).<span class="keyword">finally</span>(<span class="keyword">function</span>(){ <i class="conum" data-value="1"></i><b>(1)</b>
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">finally</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Q promiseオブジェクトとなったため <code>finally</code> が利用できる</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最初に作成したpromiseオブジェクトは <code>then</code> というメソッドを持っているので、もちろんThenableです。
<code>Q(thenable)</code> とすることでThenableなオブジェクトをQ promiseオブジェクトへと変換することが出来ます。</p>
</div>
<div class="paragraph">
<p>これは、<code>Promise.resolve(thenable)</code> と同じ仕組みといえるので、もちろん逆も可能です。</p>
</div>
<div class="paragraph">
<p>このように、Promiseライブラリはそれぞれ独自に拡張したpromiseオブジェクトを持っていますが、
Thenableという共通の概念を使うことでライブラリ間(もちろんネイティブPromiseも含めて)で相互にpromiseオブジェクトを変換することが出来ます。</p>
</div>
<div class="paragraph">
<p>このようにThenableが使われる所の多くはライブラリ内部の実装であるため、あまり目にする機会はないかもしれません。
しかしこのThenableはPromiseでも大事な概念であるため知っておくとよいでしょう。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="not-throw-use-reject">4.3. throwしないで、rejectしよう</h3>
<div class="paragraph">
<p>Promiseコンストラクタや、<code>then</code> で実行される関数は基本的に、
<code>try...catch</code> で囲まれてるような状態なので、その中で <code>throw</code> をしてもプログラムは終了しません。</p>
</div>
<div class="paragraph">
<p>Promiseの中で <code>throw</code> による例外が発生した場合は自動的に <code>try...catch</code> され、そのpromiseオブジェクトはRejectedとなります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);
});
promise.<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);<span class="comment">// =&gt; &quot;message&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>このように書いても動作的には問題ありませんが、<a href="#promise-states">promiseオブジェクトの状態</a>をRejectedにしたい場合は
<code>reject</code> という与えられた関数を呼び出すのが一般的です。</p>
</div>
<div class="paragraph">
<p>先ほどのコードは以下のように書くことが出来ます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>));
});
promise.<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);<span class="comment">// =&gt; &quot;message&quot;</span>
})</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>throw</code> が <code>reject</code> に変わったと考えれば、<code>reject</code> にはErrorオブジェクトを渡すべきであるということが分かりやすいかもしれません。</p>
</div>
<div class="sect3">
<h4 id="__reject">4.3.1. なぜrejectした方がいいのか</h4>
<div class="paragraph">
<p>そもそも、promiseオブジェクトの状態をRejectedにしたい場合に、
何故 <code>throw</code> ではなく <code>reject</code> した方がいいのでしょうか?</p>
</div>
<div class="paragraph">
<p>ひとつは <code>throw</code> が意図したものか、それとも本当に<strong>例外</strong>なのか区別が難しくなってしまうことにあります。</p>
</div>
<div class="paragraph">
<p>例えば、Chrome等の開発者ツールには例外が発生した時に、
デバッガーが自動でbreakする機能が用意されています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/chrome_on_caught_exception.png" alt="Pause On Caught Exceptions">
</div>
<div class="title">Figure 12. Pause On Caught Exceptions</div>
</div>
<div class="paragraph">
<p>この機能を有効にしていた場合、以下のように <code>throw</code> するとbreakしてしまいます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>本来デバッグとは関係ない場所でbreakしてしまうため、
Promiseの中で <code>throw</code> している箇所があると、この機能が殆ど使い物にならなくなってしまうでしょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_then_reject">4.3.2. thenでもrejectする</h4>
<div class="paragraph">
<p>Promiseコンストラクタの中では <code>reject</code> という関数そのものがあるので、
<code>throw</code> を使わないでpromiseオブジェクトをRejectedにするのは簡単でした。</p>
</div>
<div class="paragraph">
<p>では、次のような <code>then</code> の中でrejectしたい場合はどうすればいいでしょうか?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> (value) {
    setTimeout(<span class="keyword">function</span> () {
        <span class="comment">// 一定時間経って終わらなかったらrejectしたい </span><i class="conum" data-value="2"></i><b>(2)</b>
    }, <span class="integer">1000</span>);
    <span class="comment">// 時間がかかる処理 </span><i class="conum" data-value="1"></i><b>(1)</b>
    somethingHardWork();
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    <span class="comment">// タイムアウトエラー </span><i class="conum" data-value="3"></i><b>(3)</b>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>いわゆるタイムアウト処理ですが、<code>then</code> の中で <code>reject</code> を呼びたいと思った場合に、
コールバック関数に渡ってくるのは一つ前のpromiseオブジェクトの返した値だけなので困ってしまいます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Promiseを使ったタイムアウト処理の実装については <a href="#race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</a> にて詳しく解説しています。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ここで少し <code>then</code> の挙動について思い出してみましょう。</p>
</div>
<div class="paragraph">
<p><code>then</code> に登録するコールバック関数では値を <code>return</code> することができます。
この時returnした値が、次の <code>then</code> や <code>catch</code> のコールバックに渡されます。</p>
</div>
<div class="paragraph">
<p>また、returnするものはプリミティブな値に限らずオブジェクト、そしてpromiseオブジェクトも返す事が出来ます。</p>
</div>
<div class="paragraph">
<p>この時、returnしたものがpromiseオブジェクトである場合、そのpromiseオブジェクトの状態によって、
次の <code>then</code> に登録されたonFulfilledとonRejectedのうち、どちらが呼ばれるかを決めることが出来ます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    <span class="keyword">var</span> retPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="comment">// resolve or reject で onFulfilled or onRejected どちらを呼ぶか決まる</span>
    });
    <span class="keyword">return</span> retPromise;<i class="conum" data-value="1"></i><b>(1)</b>
}).then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>次に呼び出されるthenのコールバックはpromiseオブジェクトの状態によって決定される</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>つまり、この <code>retPromise</code> がRejectedになった場合は、<code>onRejected</code> が呼び出されるので、
<code>throw</code> を使わなくても <code>then</code> の中でrejectすることが出来ます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> onRejected = console.error.bind(console);
<span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    <span class="keyword">var</span> retPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
       reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this promise is rejected</span><span class="delimiter">&quot;</span></span>));
    });
    <span class="keyword">return</span> retPromise;
}).<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="paragraph">
<p>これは、<a href="#Promise.reject">Promise.reject</a> を使うことでもっと簡潔に書くことが出来ます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> onRejected = console.error.bind(console);
<span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">this promise is rejected</span><span class="delimiter">&quot;</span></span>));
}).<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__20">4.3.3. まとめ</h4>
<div class="paragraph">
<p>このセクションでは、以下のことについて学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>throw</code> ではなくて <code>reject</code> した方が安全</p>
</li>
<li>
<p><code>then</code> の中でもrejectする方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>中々使いどころが多くはないかもしれませんが、安易に <code>throw</code> してしまうよりはいい事が多いので、
覚えておくといいでしょう。</p>
</div>
<div class="paragraph">
<p>これを利用した具体的な例としては、
<a href="#race-delay-timeout">Promise.raceとdelayによるXHRのキャンセル</a> で解説しています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="deferred-and-promise">4.4. DeferredとPromise</h3>
<div class="paragraph">
<p>このセクションではDeferredとPromiseの関係について簡潔に学んでいきます。</p>
</div>
<div class="sect3">
<h4 id="_deferred">4.4.1. Deferredとは何か</h4>
<div class="paragraph">
<p>Deferredという単語はPromiseと同じコンテキストで聞いた事があるかもしれません。
有名な所だと <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> や <a href="http://cho45.stfuawsc.com/jsdeferred/">JSDeferred</a> 等があげられるでしょう。</p>
</div>
<div class="paragraph">
<p>DeferredはPromiseと違い、共通の仕様があるわけではなく、各ライブラリがそのような目的の実装をそう呼んでいます。</p>
</div>
<div class="paragraph">
<p>今回は <a href="http://api.jquery.com/category/deferred-object/">jQuery.Deferred</a> のようなDeferredの実装を中心にして話を進めます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_deferred_promise">4.4.2. DeferredとPromiseの関係</h4>
<div class="paragraph">
<p>DeferredとPromiseの関係を簡単に書くと以下のようになります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deferred は Promiseを持っている</p>
</li>
<li>
<p>Deferred は Promiseの状態を操作する特権的なメソッドを持っている</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="Ch4_AdvancedPromises/img/deferred-and-promise.png" alt="DeferredとPromise">
</div>
<div class="title">Figure 13. DeferredとPromise</div>
</div>
<div class="paragraph">
<p>この図を見ると分かりますが、DeferredとPromiseは比べるような関係ではなく、
DeferredがPromiseを内蔵しているような関係になっていることが分かります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
jQuery.Deferredの構造を簡略化したものです。もちろんPromiseを持たないDeferredの実装もあります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>図だけだと分かりにくいので、実際にPromiseを使ってDeferredを実装してみましょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="_deferred_top_on_promise">4.4.3. Deferred top on Promise</h4>
<div class="paragraph">
<p>Promiseの上にDeferredを実装した例です。</p>
</div>
<div id="deferred.js" class="listingblock">
<div class="title">deferred.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">Deferred</span>() {
    <span class="local-variable">this</span>.promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="local-variable">this</span>._resolve = resolve;
        <span class="local-variable">this</span>._reject = reject;
    }.bind(<span class="local-variable">this</span>));
}
Deferred.prototype.<span class="function">resolve</span> = <span class="keyword">function</span> (value) {
    <span class="local-variable">this</span>._resolve.call(<span class="local-variable">this</span>.promise, value);
};
Deferred.prototype.<span class="function">reject</span> = <span class="keyword">function</span> (reason) {
    <span class="local-variable">this</span>._reject.call(<span class="local-variable">this</span>.promise, reason);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>以前Promiseを使って実装した<a href="#xhr-promise.js"><code>getURL</code></a>をこのDeferredで実装しなおしてみます。</p>
</div>
<div id="xhr-deferred.js" class="listingblock executable">
<div class="title">xhr-deferred.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">Deferred</span>() {
    <span class="local-variable">this</span>.promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="local-variable">this</span>._resolve = resolve;
        <span class="local-variable">this</span>._reject = reject;
    }.bind(<span class="local-variable">this</span>));
}
Deferred.prototype.<span class="function">resolve</span> = <span class="keyword">function</span> (value) {
    <span class="local-variable">this</span>._resolve.call(<span class="local-variable">this</span>.promise, value);
};
Deferred.prototype.<span class="function">reject</span> = <span class="keyword">function</span> (reason) {
    <span class="local-variable">this</span>._reject.call(<span class="local-variable">this</span>.promise, reason);
};
<span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
    req.<span class="function">onload</span> = <span class="keyword">function</span> () {
        <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
            deferred.resolve(req.response);
        } <span class="keyword">else</span> {
            deferred.reject(<span class="keyword">new</span> Error(req.statusText));
        }
    };
    req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
        deferred.reject(<span class="keyword">new</span> Error(req.statusText));
    };
    req.send();
    <span class="keyword">return</span> deferred.promise;
}
<span class="comment">// 実行例</span>
<span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(console.error.bind(console));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Promiseの状態を操作する特権的なメソッドというのは、
promiseオブジェクトの状態をresolve、rejectすることができるメソッドで、
通常のPromiseだとコンストラクタで渡した関数の中でしか操作する事が出来ません。</p>
</div>
<div class="paragraph">
<p>Promiseで実装したものと見比べていきたいと思います。</p>
</div>
<div class="listingblock executable">
<div class="title">xhr-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="comment">// 実行例</span>
<span class="keyword">var</span> URL = <span class="string"><span class="delimiter">&quot;</span><span class="content">http://httpbin.org/get</span><span class="delimiter">&quot;</span></span>;
getURL(URL).then(<span class="keyword">function</span> <span class="function">onFulfilled</span>(value){
    console.log(value);
}).<span class="keyword">catch</span>(console.error.bind(console));</code></pre>
</div>
</div>
<div class="paragraph">
<p>2つの <code>getURL</code> を見比べて見ると以下のような違いがある事が分かります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deferred の場合は全体がPromiseで囲まれていない</p>
<div class="ulist">
<ul>
<li>
<p>関数で囲んでないため、1段ネストが減っている</p>
</li>
<li>
<p>逆にPromiseでのエラーハンドリングは行われていない</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>逆に以下の部分は同じ事をやっています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>全体的な処理の流れ</p>
<div class="ulist">
<ul>
<li>
<p><code>resolve</code>、<code>reject</code> を呼ぶタイミング</p>
</li>
</ul>
</div>
</li>
<li>
<p>関数はpromiseオブジェクトを返す</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>このDeferredはPromiseを持っているため、大きな流れは同じですが、
Deferredには特権的なメソッドを持っていることや自分で流れを制御する裁量が大きいことが分かります。</p>
</div>
<div class="paragraph">
<p>例えば、Promiseの場合はコンストラクタの中に処理を書くことが通例なので、
<code>resolve</code>、<code>reject</code> を呼ぶタイミングが大体みて分かります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject){
    <span class="comment">// この中に解決する処理を書く</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>一方Deferredの場合は、関数的なまとまりはないのでdeferredオブジェクトを作ったところから、
任意のタイミングで <code>resolve</code>、<code>reject</code> を呼ぶ感じになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();

<span class="comment">// どこかのタイミングでdeferred.resolve or deferred.rejectを呼ぶ</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>このように小さな<strong>Deferred</strong>の実装ですが<strong>Promise</strong>との違いが出ていることが分かります。</p>
</div>
<div class="paragraph">
<p>これは、Promiseが値を抽象化したオブジェクトなのに対して、
Deferredはまだ処理が終わってないという状態や操作を抽象化したオブジェクトである違いがでているのかもしれません。</p>
</div>
<div class="paragraph">
<p>言い換えると、
Promiseはこの値は将来的に正常な値(FulFilled)か異常な値(Rejected)が入るというものを予約したオブジェクトなのに対して、
Deferredはまだ処理が終わってないという事を表すオブジェクトで、
処理が終わった時の結果を取得する機構(Promise)に加えて処理を進める機構をもったものといえるかもしれません。</p>
</div>
<div class="paragraph">
<p>より詳しくDeferredについて知りたい人は以下を参照するといいでしょう。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</a></p>
</li>
<li>
<p><a href="http://skitazaki.appspot.com/translation/twisted-intro-ja/index.html">Twisted 入門 — Twisted Intro</a></p>
</li>
<li>
<p><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern">Promise anti patterns · petkaantonov/bluebird Wiki</a></p>
</li>
<li>
<p><a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery">Coming from jQuery · kriskowal/q Wiki</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>DeferredはPythonの <a href="https://twistedmatrix.com/trac/">Twisted</a> というフレームワークが最初に定義した概念です。
JavaScriptへは <a href="http://mochi.github.io/mochikit/doc/html/MochiKit/Async.html">MochiKit.Async</a> 、 <a href="http://dojotoolkit.org/reference-guide/1.9/dojo/Deferred.html">dojo/Deferred</a> 等のライブラリがその概念を持ってきたと言われています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="race-delay-timeout">4.5. Promise.raceとdelayによるXHRのキャンセル</h3>
<div class="paragraph">
<p>このセクションでは<a href="#ch2-promise-race">2章</a>で紹介した<a href="#Promise.race"><code>Promise.race</code></a>のユースケースとして、
Promise.raceを使ったタイムアウトの実装を学んでいきます。</p>
</div>
<div class="paragraph">
<p>もちろんXHRは <a href="https://developer.mozilla.org/ja/docs/XMLHttpRequest/Synchronous_and_Asynchronous_Requests">timeout</a> プロパティを持っているので、
これを利用すると簡単に出来ますが、複数のXHRを束ねたタイムアウトや他の機能でも応用が効くため、
分かりやすい非同期処理であるXHRにおけるタイムアウトによるキャンセルを例にしています。</p>
</div>
<div class="sect3">
<h4 id="_promise_4">4.5.1. Promiseで一定時間待つ</h4>
<div class="paragraph">
<p>まずはタイムアウトをPromiseでどう実現するかを見て行きたいと思います。</p>
</div>
<div class="paragraph">
<p>タイムアウトというのは一定時間経ったら何かするという処理なので、<code>setTimeout</code> を使えばいいことが分かりますね。</p>
</div>
<div class="paragraph">
<p>まずは単純に <code>setTimeout</code> をPromiseでラップした関数を作ってみましょう。</p>
</div>
<div id="delayPromise.js" class="listingblock">
<div class="title">delayPromise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>delayPromise(ms)</code> は引数で指定したミリ秒後にonFulfilledを呼ぶpromiseオブジェクトを返すので、
通常の <code>setTimeout</code> を直接使ったものと比較すると以下のように書けるだけの違いです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">setTimeout(<span class="keyword">function</span> () {
    alert(<span class="string"><span class="delimiter">&quot;</span><span class="content">100ms 経ったよ!</span><span class="delimiter">&quot;</span></span>);
}, <span class="integer">100</span>);
<span class="comment">// == ほぼ同様の動作</span>
delayPromise(<span class="integer">100</span>).then(<span class="keyword">function</span> () {
    alert(<span class="string"><span class="delimiter">&quot;</span><span class="content">100ms 経ったよ!</span><span class="delimiter">&quot;</span></span>);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここでは<strong>promiseオブジェクト</strong>であるという事が重要になってくるので覚えておいて下さい。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_race">4.5.2. Promise.raceでタイムアウト</h4>
<div class="paragraph">
<p><code>Promise.race</code> について簡単に振り返ると、
以下のようにどれか一つでもpromiseオブジェクトが解決状態になったら次の処理を実行する静的メソッドでした。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> winnerPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is winner</span><span class="delimiter">'</span></span>);
        }, <span class="integer">4</span>);
    });
<span class="keyword">var</span> loserPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(<span class="keyword">function</span> () {
            console.log(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
            resolve(<span class="string"><span class="delimiter">'</span><span class="content">this is loser</span><span class="delimiter">'</span></span>);
        }, <span class="integer">1000</span>);
    });
<span class="comment">// 一番最初のものがresolveされた時点で終了</span>
Promise.race([winnerPromise, loserPromise]).then(<span class="keyword">function</span> (value) {
    console.log(value);    <span class="comment">// =&gt; 'this is winner'</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>先ほどの<a href="#delayPromise.js">delayPromise</a>と別のpromiseオブジェクトを、
<code>Promise.race</code> によって競争させることで簡単にタイムアウトが実装出来ます。</p>
</div>
<div id="simple-timeout-promise.js" class="listingblock">
<div class="title">simple-timeout-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="keyword">function</span> () {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Operation timed out after </span><span class="delimiter">'</span></span> + ms + <span class="string"><span class="delimiter">'</span><span class="content"> ms</span><span class="delimiter">'</span></span>);
        });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>timeoutPromise(比較対象のpromise, ms)</code> はタイムアウト処理を入れたい
promiseオブジェクトとタイムアウトの時間を受け取り、<code>Promise.race</code> により競争させたpromiseオブジェクトを返します。</p>
</div>
<div class="paragraph">
<p><code>timeoutPromise</code> を使うことで以下のようにタイムアウト処理を書くことが出来るようになります。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="keyword">function</span> () {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">Operation timed out after </span><span class="delimiter">'</span></span> + ms + <span class="string"><span class="delimiter">'</span><span class="content"> ms</span><span class="delimiter">'</span></span>);
        });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}
<span class="comment">// 実行例</span>
<span class="keyword">var</span> taskPromise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve){
    <span class="comment">// 何らかの処理</span>
    <span class="keyword">var</span> delay = Math.random() * <span class="integer">2000</span>;
    setTimeout(<span class="keyword">function</span>(){
        resolve(delay + <span class="string"><span class="delimiter">&quot;</span><span class="content">ms</span><span class="delimiter">&quot;</span></span>);
    }, delay);
});
timeoutPromise(taskPromise, <span class="integer">1000</span>).then(<span class="keyword">function</span>(value){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">taskPromiseが時間内に終わった : </span><span class="delimiter">&quot;</span></span> + value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.log(<span class="string"><span class="delimiter">&quot;</span><span class="content">タイムアウトになってしまった</span><span class="delimiter">&quot;</span></span>, error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>タイムアウトになった場合はエラーが呼ばれるように出来ましたが、
このままでは<em>通常のエラー</em>と<em>タイムアウトのエラー</em>の区別がつかなくなってしまいます。</p>
</div>
<div class="paragraph">
<p>この <code>Error</code> オブジェクトの区別をしやすくするため、
<code>Error</code> オブジェクトのサブクラスとして <code>TimeoutError</code> を定義したいと思います。</p>
</div>
</div>
<div class="sect3">
<h4 id="__error">4.5.3. カスタムErrorオブジェクト</h4>
<div class="paragraph">
<p><code>Error</code> オブジェクトはECMAScriptのビルトインオブジェクトです。</p>
</div>
<div class="paragraph">
<p>ECMAScript5では完璧に <code>Error</code> を継承したものを作る事は不可能ですが(スタックトレース周り等)、
今回は通常のErrorとは区別を付けたいという目的なので、それを満たせる <code>TimeoutError</code> オブジェクトを作成します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>ECMAScript6では <code>class</code> 構文を使うことで内部的にも正確に継承を行うことが出来ます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="reserved">class</span> MyError <span class="reserved">extends</span> Error{
    <span class="comment">// Errorを継承したオブジェクト</span>
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>error instanceof TimeoutError</code> というように利用できる <code>TimeoutError</code> を定義すると
以下のようになります。</p>
</div>
<div id="TimeoutError.js" class="listingblock">
<div class="title">TimeoutError.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">copyOwnFrom</span>(target, source) {
    Object.getOwnPropertyNames(source).forEach(<span class="keyword">function</span> (propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
    });
    <span class="keyword">return</span> target;
}
<span class="keyword">function</span> <span class="function">TimeoutError</span>() {
    <span class="keyword">var</span> superInstance = Error.apply(<span class="predefined-constant">null</span>, <span class="local-variable">arguments</span>);
    copyOwnFrom(<span class="local-variable">this</span>, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TimeoutError</code> というコンストラクタ関数を定義して、このコンストラクタにErrorをprototype継承させています。</p>
</div>
<div class="paragraph">
<p>使い方は通常の <code>Error</code> オブジェクトと同じで以下のように <code>throw</code> するなどして利用できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(){
    <span class="keyword">throw</span> TimeoutError(<span class="string"><span class="delimiter">&quot;</span><span class="content">timeout</span><span class="delimiter">&quot;</span></span>);
});

promise.<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.log(error <span class="keyword">instanceof</span> TimeoutError);<span class="comment">// true</span>
});
</code></pre>
</div>
</div>
<div class="paragraph">
<p>この <code>TimeoutError</code> を使えば、タイムアウトによるErrorオブジェクトなのか、他の原因のErrorオブジェクトなのかが容易に判定できるようになります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>今回紹介したビルトインオブジェクトを継承したオブジェクトの作成方法については
<a href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</a> で詳しく紹介されています。
また、 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error - JavaScript | MDN</a> にもErrorオブジェクトについて書かれています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__xhr">4.5.4. タイムアウトによるXHRのキャンセル</h4>
<div class="paragraph">
<p>ここまでくれば、どのようにPromiseを使ったXHRのキャンセルを実装するか見えてくるかもしれません。</p>
</div>
<div class="paragraph">
<p>XHRのキャンセル自体は <code>XMLHttpRequest</code> オブジェクトの <code>abort()</code> メソッドを呼ぶだけなので難しくないですね。</p>
</div>
<div class="paragraph">
<p><code>abort()</code> メソッドを外から呼べるようにするために、今までのセクションにもでてきた<a href="#xhr-promise.js"><code>getURL</code></a>を少し拡張して、
XHRを包んだpromiseオブジェクトと共にそのXHRを中止するメソッドを持つオブジェクトを返すようにしています。</p>
</div>
<div id="delay-race-cancel.js" class="listingblock">
<div class="title">delay-race-cancel.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">cancelableXHR</span>(URL) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
            req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
            req.<span class="function">onload</span> = <span class="keyword">function</span> () {
                <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                    resolve(req.response);
                } <span class="keyword">else</span> {
                    reject(<span class="keyword">new</span> Error(req.statusText));
                }
            };
            req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(req.statusText));
            };
            req.<span class="function">onabort</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">abort this request</span><span class="delimiter">'</span></span>));
            };
            req.send();
        });
    <span class="keyword">var</span> <span class="function">abort</span> = <span class="keyword">function</span> () {
        <span class="comment">// 既にrequestが止まってなければabortする</span>
        <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span>
        <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    <span class="keyword">return</span> {
        <span class="key">promise</span>: promise,
        <span class="key">abort</span>: abort
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで必要な要素は揃ったので後は、Promiseを使った処理のフローに並べていくだけです。
大まかな流れとしては以下のようになります。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>cancelableXHR</code> を使いXHRのpromiseオブジェクトと中止を呼び出すメソッドを取得する</p>
</li>
<li>
<p><code>timeoutPromise</code> を使いXHRのpromiseとタイムアウト用のpromiseを <code>Promise.race</code> で競争させる</p>
<div class="ulist">
<ul>
<li>
<p>XHRが時間内に取得出来た場合</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>通常のpromiseと同様に <code>then</code> で中身を取得する</p>
</li>
</ol>
</div>
</li>
<li>
<p>タイムアウトとなった場合は</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>throw TimeoutError</code> されるので <code>catch</code> する</p>
</li>
<li>
<p>catchしたエラーオブジェクトが <code>TimeoutError</code> のものだったら <code>abort</code> を呼び出してXHRをキャンセルする</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>これらの要素を全てまとめると次のように書けます。</p>
</div>
<div id="delay-race-cancel-play.js" class="listingblock executable">
<div class="title">delay-race-cancel-play.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">copyOwnFrom</span>(target, source) {
    Object.getOwnPropertyNames(source).forEach(<span class="keyword">function</span> (propName) {
        Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
    });
    <span class="keyword">return</span> target;
}
<span class="keyword">function</span> <span class="function">TimeoutError</span>() {
    <span class="keyword">var</span> superInstance = Error.apply(<span class="predefined-constant">null</span>, <span class="local-variable">arguments</span>);
    copyOwnFrom(<span class="local-variable">this</span>, superInstance);
}
TimeoutError.prototype = Object.create(Error.prototype);
TimeoutError.prototype.constructor = TimeoutError;
<span class="keyword">function</span> <span class="function">delayPromise</span>(ms) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        setTimeout(resolve, ms);
    });
}
<span class="keyword">function</span> <span class="function">timeoutPromise</span>(promise, ms) {
    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="keyword">function</span> () {
            <span class="keyword">return</span> Promise.reject(<span class="keyword">new</span> TimeoutError(<span class="string"><span class="delimiter">'</span><span class="content">Operation timed out after </span><span class="delimiter">'</span></span> + ms + <span class="string"><span class="delimiter">'</span><span class="content"> ms</span><span class="delimiter">'</span></span>));
        });
    <span class="keyword">return</span> Promise.race([promise, timeout]);
}
<span class="keyword">function</span> <span class="function">cancelableXHR</span>(URL) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
            req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
            req.<span class="function">onload</span> = <span class="keyword">function</span> () {
                <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                    resolve(req.response);
                } <span class="keyword">else</span> {
                    reject(<span class="keyword">new</span> Error(req.statusText));
                }
            };
            req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(req.statusText));
            };
            req.<span class="function">onabort</span> = <span class="keyword">function</span> () {
                reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">abort this request</span><span class="delimiter">'</span></span>));
            };
            req.send();
        });
    <span class="keyword">var</span> <span class="function">abort</span> = <span class="keyword">function</span> () {
        <span class="comment">// 既にrequestが止まってなければabortする</span>
        <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span>
        <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) {
            req.abort();
        }
    };
    <span class="keyword">return</span> {
        <span class="key">promise</span>: promise,
        <span class="key">abort</span>: abort
    };
}
<span class="keyword">var</span> object = cancelableXHR(<span class="string"><span class="delimiter">'</span><span class="content">http://httpbin.org/get</span><span class="delimiter">'</span></span>);
<span class="comment">// main</span>
timeoutPromise(object.promise, <span class="integer">1000</span>).then(<span class="keyword">function</span> (contents) {
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">Contents</span><span class="delimiter">'</span></span>, contents);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutError) {
        object.abort();
        <span class="keyword">return</span> console.log(error);
    }
    console.log(<span class="string"><span class="delimiter">'</span><span class="content">XHR Error :</span><span class="delimiter">'</span></span>, error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、一定時間後に解決されるpromiseオブジェクトを使ったタイムアウト処理が実現できました。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
通常の開発の場合は繰り返し使えるように、それぞれファイルに分割して定義しておくといいですね。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_promise_5">4.5.5. promiseと操作メソッド</h4>
<div class="paragraph">
<p>先ほどの<a href="#delay-race-cancel.js"><code>cancelableXHR</code></a>はpromiseオブジェクトと操作のメソッドが
一緒になったオブジェクトを返すようにしていたため少し分かりにくかったかもしれません。</p>
</div>
<div class="paragraph">
<p>一つの関数は一つの値(promiseオブジェクト)を返すほうが見通しがいいと思いますが、
<code>cancelableXHR</code> の中で生成した <code>req</code> は外から参照できないので、特定のメソッド(先ほどのケースは <code>abort</code>)からは触れるようにする必要があります。</p>
</div>
<div class="paragraph">
<p>返すpromiseオブジェクト自体を拡張して <code>abort</code> 出来るようにするという手段もあると思いますが、
promiseオブジェクトは値を抽象化したオブジェクトであるため、何でも操作用のメソッドをつけていくと複雑になってしまうかもしれません。</p>
</div>
<div class="paragraph">
<p>一つの関数で全てやろうとしてるのがそもそも良くないので、
ひとつの関数で何でもやるのは止めて、以下のように関数に分離していくというのが妥当な気がします。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>XHRを行うpromiseオブジェクトを返す</p>
</li>
<li>
<p>promiseオブジェクトを渡したら該当するXHRを止める</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらの処理をまとめたモジュールを作れば今後の拡張がしやすいですし、
一つの関数がやることも小さくて済むので見通しも良くなると思います。</p>
</div>
<div class="paragraph">
<p>モジュールの作り方は色々作法(AMD,CommonJS,ES6 module etc..)があるので
ここでは、先ほどの <code>cancelableXHR</code> をNode.jsのモジュールとして作りなおしてみます。</p>
</div>
<div id="cancelableXHR.js" class="listingblock">
<div class="title">cancelableXHR.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> requestMap = {};
<span class="keyword">function</span> <span class="function">createXHRPromise</span>(URL) {
    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onreadystatechange</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.readyState === XMLHttpRequest.DONE) {
                <span class="keyword">delete</span> requestMap[URL];
            }
        };
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.<span class="function">onabort</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">'</span><span class="content">abort this req</span><span class="delimiter">'</span></span>));
        };
        req.send();
    });
    requestMap[URL] = {
        <span class="key">promise</span>: promise,
        <span class="key">request</span>: req
    };
    <span class="keyword">return</span> promise;
}

<span class="keyword">function</span> <span class="function">abortPromise</span>(promise) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> promise === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> request;
    Object.keys(requestMap).some(<span class="keyword">function</span> (URL) {
        <span class="keyword">if</span> (requestMap[URL].promise === promise) {
            request = requestMap[URL].request;
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
    });
    <span class="keyword">if</span> (request != <span class="predefined-constant">null</span> &amp;&amp; request.readyState !== XMLHttpRequest.UNSENT) {
        request.abort();
    }
}
module.exports.createXHRPromise = createXHRPromise;
module.exports.abortPromise = abortPromise;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使い方もシンプルに <code>createXHRPromise</code> でXHRのpromiseオブジェクトを作成して、
そのXHRを <code>abort</code> したい場合は <code>abortPromise(promise)</code> にpromiseオブジェクトを渡すという感じで利用できるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> cancelableXHR = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./cancelableXHR</span><span class="delimiter">&quot;</span></span>);

<span class="keyword">var</span> xhrPromise = cancelableXHR.createXHRPromise(<span class="string"><span class="delimiter">'</span><span class="content">http://httpbin.org/get</span><span class="delimiter">'</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
xhrPromise.<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    <span class="comment">// abort されたエラーが呼ばれる</span>
});
cancelableXHR.abortPromise(xhrPromise);<i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XHRをラップしたpromiseオブジェクトを作成</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>1で作成したpromiseオブジェクトのリクエストをキャンセル</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__21">4.5.6. まとめ</h4>
<div class="paragraph">
<p>ここでは以下の事について学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一定時間後に解決されるdelayPromise</p>
</li>
<li>
<p>delayPromiseとPromise.raceを使ったタイムアウトの実装</p>
</li>
<li>
<p>XHRのpromiseのリクエストのキャンセル</p>
</li>
<li>
<p>モジュール化によるpromiseオブジェクトと操作の分離</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Promiseは処理のフローを制御する力に優れているため、
それを最大限活かすためには一つの関数でやり過ぎないで処理を小さく分けること等、
今までのJavaScriptで言われているような事をより意識していいのかもしれません。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-done">4.6. Promise.prototype.done とは何か?</h3>
<div class="paragraph">
<p>既存のPromise実装ライブラリを利用したことがある人は、
<code>then</code> の代わりに使う <code>done</code> というメソッドを見たことがあるかもしれません。</p>
</div>
<div class="paragraph">
<p>それらのライブラリでは <code>Promise.prototype.done</code> というような実装が存在し、
使い方は <code>then</code> と同じですが、promiseオブジェクトを返さないようになっています。</p>
</div>
<div class="paragraph">
<p><code>Promise.prototype.done</code> は、<a href="#es6-promises">ES6 Promises</a>や<a href="#promises-aplus">Promises/A+</a>の仕様には
存在していない記述ですが、多くのライブラリが実装しています。</p>
</div>
<div class="paragraph">
<p>このセクションでは、<code>Promise.prototype.done</code> とは何か?
また何故このようなメソッドが多くのライブラリで実装されているかについて学んでいきましょう。</p>
</div>
<div class="sect3">
<h4 id="_done">4.6.1. doneを使ったコード例</h4>
<div class="paragraph">
<p>実際にdoneを使ったコードを見てみると <code>done</code> の挙動が分かりやすいと思います。</p>
</div>
<div id="promise-done-example.js" class="listingblock executable">
<div class="title">promise-done-example.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">if</span> (<span class="keyword">typeof</span> Promise.prototype.done === <span class="string"><span class="delimiter">'</span><span class="content">undefined</span><span class="delimiter">'</span></span>) {
    Promise.prototype.<span class="function">done</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
        <span class="local-variable">this</span>.then(onFulfilled, onRejected).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
            setTimeout(<span class="keyword">function</span> () {
                <span class="keyword">throw</span> error;
            }, <span class="integer">0</span>);
        });
    };
}
<span class="keyword">var</span> promise = Promise.resolve();
promise.done(<span class="keyword">function</span> () {
    JSON.parse(<span class="string"><span class="delimiter">'</span><span class="content">this is not json</span><span class="delimiter">'</span></span>);    <span class="comment">// =&gt; SyntaxError: JSON.parse</span>
});
<span class="comment">// =&gt; ブラウザの開発ツールのコンソールを開いてみましょう</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最初に述べたように、<code>Promise.prototype.done</code> は仕様としては存在しないため、
利用する際は実装されているライブラリを使うか自分で実装する必要があります。</p>
</div>
<div class="paragraph">
<p>実装については後で解説しますが、まずは <code>then</code> を使った場合と <code>done</code> を使ったものを比較してみます。</p>
</div>
<div class="listingblock executable">
<div class="title">thenを使った場合</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = Promise.resolve();
promise.then(<span class="keyword">function</span> () {
    JSON.parse(<span class="string"><span class="delimiter">&quot;</span><span class="content">this is not json</span><span class="delimiter">&quot;</span></span>);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);<span class="comment">// =&gt; &quot;SyntaxError: JSON.parse&quot;</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>比べて見ると以下のような違いがあることが分かります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> はpromiseオブジェクトを返さない</p>
<div class="ulist">
<ul>
<li>
<p>つまり、doneの後に <code>catch</code> 等のメソッドチェーンはできない</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>done</code> の中で発生したエラーはそのまま外に例外として投げられる</p>
<div class="ulist">
<ul>
<li>
<p>つまり、Promiseによるエラーハンドリングが行われない</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>done</code> はpromiseオブジェクトを返していないので、
Promise chainの最後におくメソッドというのはわかると思います。</p>
</div>
<div class="paragraph">
<p>また、Promiseには強力なエラーハンドリング機能があると紹介していましたが、
<code>done</code> の中ではそのエラーハンドリングをワザと突き抜けて例外を出すようになっています。</p>
</div>
<div class="paragraph">
<p>何故このようなPromiseの機能とは相反するメソッドが、多くのライブラリで実装されているかについては
次のようなPromiseの失敗例を見ていくと分かるかもしれません。</p>
</div>
</div>
<div class="sect3">
<h4 id="__22">4.6.2. 沈黙したエラー</h4>
<div class="paragraph">
<p>Promiseには強力なエラーハンドリング機能がありますが、
(デバッグツールが上手く働かない場合に)
この機能がヒューマンエラーをより複雑なものにしてしまう一面があります。</p>
</div>
<div class="paragraph">
<p>これは、<a href="#then-or-catch">then or catch?</a>でも同様の内容が出てきたことを覚えているかもしれません。</p>
</div>
<div class="paragraph">
<p>次のような、promiseオブジェクトを返す関数を考えてみましょう。</p>
</div>
<div id="json-promise.js" class="listingblock">
<div class="title">json-promise.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">JSONPromise</span>(value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        resolve(JSON.parse(value));
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>渡された値を <code>JSON.parse</code> してpromiseオブジェクトを返す関数ですね。</p>
</div>
<div class="paragraph">
<p>以下のように使うことができ、<code>JSON.parse</code> はパースに失敗すると例外を投げるので、
それを <code>catch</code> することが出来ます。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">JSONPromise</span>(value) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve) {
        resolve(JSON.parse(value));
    });
}
<span class="comment">// 実行例</span>
<span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">jsonではない文字列</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    console.log(object);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    <span class="comment">// =&gt; JSON.parseで例外が発生した時</span>
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>ちゃんと <code>catch</code> していれば何も問題がないのですが、その処理を忘れてしまうというミスを
した時にどこでエラーが発生してるのかわからなくなるというヒューマンエラーを助長させる面があります。</p>
</div>
<div class="listingblock">
<div class="title">catchによるエラーハンドリングを忘れてしまった場合</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">jsonではない文字列</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    console.log(object);
}); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>例外が投げられても何も処理されない</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>JSON.parse</code> のような分かりやすい例の場合はまだ良いですが、
メソッドをtypoしたことによるSyntax Errorなどはより深刻な問題となりやすいです。</p>
</div>
<div class="listingblock">
<div class="title">typoによるエラー</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="content">{}</span><span class="delimiter">&quot;</span></span>;
JSONPromise(string).then(<span class="keyword">function</span> (object) {
    conosle.log(object);<i class="conum" data-value="1"></i><b>(1)</b>
});</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>conosle というtypoがある</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>この場合は、<code>console</code> を <code>conosle</code> とtypoしているため、以下のようなエラーが発生するはずです。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>ReferenceError: conosle is not defined</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>しかし、Promiseではtry-catchされるため、エラーが握りつぶされてしまうという現象が発生しやすくなります。
毎回、正しく <code>catch</code> の処理を書くことが出来る場合は何も問題ありませんが、
Promiseの実装によってはこのようなミスが検知しにくくなるケースがあることを知っておくべきでしょう。</p>
</div>
<div class="paragraph">
<p>このようなエラーの握りつぶしは<em>unhandled rejection</em>と言われることがあります。
Rejectedされた時の処理がないというそのままの意味ですね。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>このunhandled rejectionが検知しにくい問題はPromiseの実装に依存します。
例えば、 <a href="https://github.com/yahoo/ypromise">ypromise</a> はunhandled rejectionがある場合は、その事をコンソールに表示します。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Promise rejected but no error handlers were registered to it</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>また、 <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> の場合も、
明らかに人間のミスにみえるReferenceErrorの場合などはそのままコンソールにエラーを表示してくれます。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Possibly unhandled ReferenceError. conosle is not defined</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>ネイティブのPromiseの場合も同様にこの問題への対処としてGC-based unhandled rejection trackingというものが
搭載されつつあります。</p>
</div>
<div class="paragraph">
<p>これはpromiseオブジェクトがガーベッジコレクションによって回収されるときに、
それがunhandled rejectionであるなら、エラー表示をするという仕組みがベースとなっているようです。</p>
</div>
<div class="paragraph">
<p><a href="https://twitter.com/domenic/status/461154989856264192">Firefox</a> や <a href="https://code.google.com/p/v8/issues/detail?id=3093">Chrome</a> のネイティブPromiseでは一部実装されています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_done_2">4.6.3. doneの実装</h4>
<div class="paragraph">
<p>Promiseにおける <code>done</code> は先程のエラーの握りつぶしを避けるにはどうするかという方法論として、
そもそもエラーハンドリングをしなければいい という豪快な解決方法を提供するメソッドです。</p>
</div>
<div class="paragraph">
<p><code>done</code> はPromiseの上に実装することが出来るので、
<code>Promise.prototype.done</code> というPromiseのprototype拡張として実装してみましょう。</p>
</div>
<div id="promise-prototype-done.js" class="listingblock">
<div class="title">promise-prototype-done.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">if</span> (<span class="keyword">typeof</span> Promise.prototype.done === <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
    Promise.prototype.<span class="function">done</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
        <span class="local-variable">this</span>.then(onFulfilled, onRejected).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
            setTimeout(<span class="keyword">function</span> () {
                <span class="keyword">throw</span> error;
            }, <span class="integer">0</span>);
        });
    };
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>どのようにPromiseの外へ例外を投げているかというと、
setTimeoutの中でthrowをすることで、外へそのまま例外を投げられることを利用しています。</p>
</div>
<div class="listingblock">
<div class="title">setTimeoutのコールバック内での例外</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">try</span>{
    setTimeout(<span class="keyword">function</span> <span class="function">callback</span>() {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>);<i class="conum" data-value="1"></i><b>(1)</b>
    }, <span class="integer">0</span>);
}<span class="keyword">catch</span>(error){
    console.error(error);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>この例外はキャッチされない</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>なぜ非同期の <code>callback</code> 内での例外をキャッチ出来ないのかは以下が参考になります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://techblog.yahoo.co.jp/programming/javascript_error/">JavaScriptと非同期のエラー処理 - Yahoo! JAPAN Tech Blog</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#promise-prototype-done.js"><code>Promise.prototype.done</code></a> をよく見てみると、何も <code>return</code> していないこともわかると思います。
つまり、<code>done</code> は「ここでPromise chainは終了して、例外が起きた場合はそのままpromiseの外へ投げ直す」という処理になっています。</p>
</div>
<div class="paragraph">
<p>実装や環境がしっかり対応していれば、<em>unhandled rejection</em>の検知はできるため、必ずしも <code>done</code> が必要というわけではなく、
また今回の<a href="#promise-prototype-done.js"><code>Promise.prototype.done</code></a>のように、<code>done</code> は既存のPromiseの上に実装することができるため、
<a href="#es6-promises">ES6 Promises</a>の仕様そのものには入らなかったと言えるかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
今回の <code>Promise.prototype.done</code> の実装は <a href="https://www.promisejs.org/">promisejs.org</a> を参考にしています。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="__23">4.6.4. まとめ</h4>
<div class="paragraph">
<p>このセクションでは、 <a href="https://github.com/kriskowal/q/wiki/API-Reference#promisedoneonfulfilled-onrejected-onprogress">Q</a> や <a href="https://github.com/petkaantonov/bluebird">Bluebird</a> や <a href="https://github.com/cscott/prfun#promisedone&#8212;undefined">prfun</a> 等
多くのPromiseライブラリで実装されている <code>done</code> の基礎的な実装と、<code>then</code> とはどのような違いがあるかについて学びました。</p>
</div>
<div class="paragraph">
<p><code>done</code> には2つの側面があることがわかりました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>done</code> の中で起きたエラーは外へ例外として投げ直す</p>
</li>
<li>
<p>Promise chain を終了するという宣言</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#then-or-catch">then or catch?</a> と同様にPromiseにより沈黙してしまったエラーについては、
デバッグツールやライブラリの改善等で殆どのケースでは問題ではなくなるかもしれません。</p>
</div>
<div class="paragraph">
<p>また、<code>done</code> は値を返さない事でそれ以上Promise chainを繋げる事ができなくなるため、
そのような統一感を持たせるという用途で <code>done</code> を使うことも出来ます。</p>
</div>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a> では根本に用意されてる機能はあまり多くありません。
そのため、自ら拡張したり、拡張したライブラリ等を利用するケースが多いと思います。</p>
</div>
<div class="paragraph">
<p>その時でも何でもやり過ぎると、せっかく非同期処理をPromiseでまとめても複雑化してしまう場合があるため、
統一感を持たせるというのは抽象的なオブジェクトであるPromiseにおいては大事な部分と言えるかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="http://blog.getify.com/promises-part-4/">Promises: The Extension Problem (part 4) | getiblog</a> では、
Promiseの拡張を書く手法について書かれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Promise.prototype</code> を拡張する方法</p>
</li>
<li>
<p>Wrapper/Delegate を使った抽象レイヤーを作る方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>また、Delegateを利用した方法については、 <a href="http://speakingjs.com/es5/ch28.html">Chapter 28. Subclassing Built-ins</a> にて
詳しく解説されています。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-and-method-chain">4.7. Promiseとメソッドチェーン</h3>
<div class="paragraph">
<p>Promiseは <code>then</code> や <code>catch</code> 等のメソッドを繋げて書いていきます。
これはDOMやjQuery等でよくみられるメソッドチェーンとよく似ています。</p>
</div>
<div class="paragraph">
<p>一般的なメソッドチェーンは <code>this</code> を返すことで、メソッドを繋げて書けるようになっています。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>メソッドチェーンの作り方については <a href="http://taiju.hatenablog.com/entry/20100307/1267962826">メソッドチェーンの作り方 - あと味</a> などを参照するといいでしょう。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一方、Promiseは<a href="#then-return-new-promise">毎回新しいpromiseオブジェクトを返す</a>ようになっていますが、
一般的なメソッドチェーンと見た目は全く同じです。</p>
</div>
<div class="paragraph">
<p>このセクションでは、一般的なメソッドチェーンで書かれたものを
インターフェースはそのままで内部的にはPromiseで処理されるようにする方法について学んでいきたいと思います。</p>
</div>
<div class="sect3">
<h4 id="_fs">4.7.1. fsのメソッドチェーン</h4>
<div class="paragraph">
<p>以下のような <a href="http://nodejs.org/api/fs.html">Node.jsのfs</a>モジュールを例にしてみたいと思います。</p>
</div>
<div class="paragraph">
<p>また、今回の例は見た目のわかりやすさを重視しているため、
現実的にはあまり有用なケースとは言えないかもしれません。</p>
</div>
<div id="fs-method-chain.js" class="listingblock">
<div class="title">fs-method-chain.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">File</span>() {
    <span class="local-variable">this</span>.lastValue = <span class="predefined-constant">null</span>;
}
<span class="comment">// Static method for File.prototype.read</span>
File.<span class="function">read</span> = <span class="keyword">function</span> <span class="function">FileRead</span>(filePath) {
    <span class="keyword">var</span> file = <span class="keyword">new</span> File();
    <span class="keyword">return</span> file.read(filePath);
};
File.prototype.<span class="function">read</span> = <span class="keyword">function</span> (filePath) {
    <span class="local-variable">this</span>.lastValue = fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">transform</span> = <span class="keyword">function</span> (fn) {
    <span class="local-variable">this</span>.lastValue = fn.call(<span class="local-variable">this</span>, <span class="local-variable">this</span>.lastValue);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">write</span> = <span class="keyword">function</span> (filePath) {
    <span class="local-variable">this</span>.lastValue = fs.writeFileSync(filePath, <span class="local-variable">this</span>.lastValue);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
module.exports = File;</code></pre>
</div>
</div>
<div class="paragraph">
<p>このモジュールは以下のようにread &#8594; transform &#8594; writeという流れを
メソッドチェーンで表現することができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-method-chain</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">var</span> inputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">input.txt</span><span class="delimiter">&quot;</span></span>,
    outputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">output.txt</span><span class="delimiter">&quot;</span></span>;
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>transform</code> は引数で受け取った値を変更する関数を渡して処理するメソッドです。
この場合は、readで読み込んだ内容の先頭に <code>&gt;&gt;</code> という文字列を追加しているだけです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_fs">4.7.2. Promiseによるfsのメソッドチェーン</h4>
<div class="paragraph">
<p>次に先ほどの<a href="#fs-method-chain.js">メソッドチェーン</a>をインターフェースはそのまま維持して
内部的にPromiseを使った処理にしてみたいと思います。</p>
</div>
<div id="fs-promise-chain.js" class="listingblock">
<div class="title">fs-promise-chain.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> fs = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">function</span> <span class="function">File</span>() {
    <span class="local-variable">this</span>.promise = Promise.resolve();
}
<span class="comment">// Static method for File.prototype.read</span>
File.<span class="function">read</span> = <span class="keyword">function</span> (filePath) {
    <span class="keyword">var</span> file = <span class="keyword">new</span> File();
    <span class="keyword">return</span> file.read(filePath);
};

File.prototype.<span class="function">then</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(onFulfilled, onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>] = <span class="keyword">function</span> (onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.<span class="keyword">catch</span>(onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
File.prototype.<span class="function">read</span> = <span class="keyword">function</span> (filePath) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(<span class="keyword">function</span> () {
        <span class="keyword">return</span> fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    });
};
File.prototype.<span class="function">transform</span> = <span class="keyword">function</span> (fn) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(fn);
};
File.prototype.<span class="function">write</span> = <span class="keyword">function</span> (filePath) {
    <span class="keyword">return</span> <span class="local-variable">this</span>.then(<span class="keyword">function</span> (data) {
        <span class="keyword">return</span> fs.writeFileSync(filePath, data)
    });
};
module.exports = File;</code></pre>
</div>
</div>
<div class="paragraph">
<p>内部に持ってるpromiseオブジェクトに対するエイリアスとして
<code>then</code> と <code>catch</code> を持たせていますが、それ以外のインターフェースは全く同じ使い方となっています。</p>
</div>
<div class="paragraph">
<p>そのため、先ほどのコードで <code>require</code> するモジュールを変更しただけで動作します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">var</span> inputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">input.txt</span><span class="delimiter">&quot;</span></span>,
    outputFilePath = <span class="string"><span class="delimiter">&quot;</span><span class="content">output.txt</span><span class="delimiter">&quot;</span></span>;
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>File.prototype.then</code> というメソッドは、
<code>this.promise.then</code> が返す新しいpromiseオブジェクトを <code>this.promise</code> に対して代入しています。</p>
</div>
<div class="paragraph">
<p>これはどういうことなのかというと、以下のように擬似的に展開してみると分かりやすいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath);
<span class="comment">// =&gt; 擬似的に以下のような流れに展開できる</span>
promise.then(<span class="keyword">function</span> <span class="function">read</span>(){
        <span class="keyword">return</span> fs.readFileSync(filePath, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf-8</span><span class="delimiter">&quot;</span></span>);
    }).then(<span class="keyword">function</span> <span class="function">transform</span>(content) {
         <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    }).then(<span class="keyword">function</span> <span class="function">write</span>(){
        <span class="keyword">return</span> fs.writeFileSync(filePath, data);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>promise = promise.then(...)</code> という書き方は一見すると、上書きしているようにみえるため、
それまでのpromiseのchainが途切れてしまうと思うかもしれません。</p>
</div>
<div class="paragraph">
<p>イメージとしては <code>promise = addPromiseChain(promise, fn);</code> のような感じになっていて、
既存のpromiseオブジェクトに対して新たな処理を<strong>追加</strong>したpromiseオブジェクトを作って返すため、
自分で逐次的に処理する機構を実装しなくても問題ないわけです。</p>
</div>
</div>
<div class="sect3">
<h4 id="__24">4.7.3. 両者の違い</h4>
<div class="sect4">
<h5 id="__25">同期と非同期</h5>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a>と<a href="#fs-promise-chain.js">Promise版</a>の違いを見ていくと、
そもそも両者には同期的、非同期的という大きな違いがあります。</p>
</div>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a> のようなメソッドチェーンでもキュー等の処理を実装すれば、
非同期的なほぼ同様のメソッドチェーンを実装出来ますが、複雑になるため今回は単純な同期的なメソッドチェーンにしました。</p>
</div>
<div class="paragraph">
<p>Promise版は<a href="#promise-is-always-async">コラム: Promiseは常に非同期?</a>で紹介したように
常に非同期処理となるため、promiseを使ったメソッドチェーンも非同期となっています。</p>
</div>
</div>
<div class="sect4">
<h5 id="__26">エラーハンドリング</h5>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a>にはエラーハンドリングの処理は入っていないですが、
同期処理であるため全体を <code>try-catch</code> で囲む事で行えます。</p>
</div>
<div class="paragraph">
<p><a href="#fs-promise-chain.js">Promise版</a> では内部で利用するpromiseオブジェクトの
<code>then</code> と <code>catch</code> へのエイリアスを用意してあるため、通常のpromiseと同じように <code>catch</code> によってエラーハンドリングが行えます。</p>
</div>
<div class="listingblock">
<div class="title">fs-promise-chainでのエラーハンドリング</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> File = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">./fs-promise-chain</span><span class="delimiter">&quot;</span></span>);
File.read(inputFilePath)
    .transform(<span class="keyword">function</span> (content) {
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">&gt;&gt;</span><span class="delimiter">&quot;</span></span> + content;
    })
    .write(outputFilePath)
    .<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
        console.error(error);
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#fs-method-chain.js">fs-method-chain.js</a>に非同期処理を加えたものを自力で実装する場合、
エラーハンドリングが大きな問題となるため、非同期処理にしたい時は
Promiseを使うと比較的簡単に実装できると言えるかもしれません。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_promise_6">4.7.4. Promise以外での非同期処理</h4>
<div class="paragraph">
<p>このメソッドチェーンと非同期処理を見てNode.jsに慣れている方は <a href="http://nodejs.org/api/stream.html">Stream</a> が思い浮かぶと思います。</p>
</div>
<div class="paragraph">
<p><a href="http://nodejs.org/api/stream.html">Stream</a> を使うと、
<code>this.lastValue</code> のような値を保持する必要がなくなる事や大きなファイルの扱いが改善されます。
また、Promiseを使った例に比べるとより高速に処理できる可能性が高いと思います。</p>
</div>
<div class="listingblock">
<div class="title">streamによるread&#8594;transform&#8594;write</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">readableStream.pipe(transformStream).pipe(writableStream);</code></pre>
</div>
</div>
<div class="paragraph">
<p>そのため、非同期処理には常にPromiseが最適という訳ではなく、
目的と状況にあった実装をしていくことを考えていくべきでしょう。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Node.jsのStreamはEventをベースにしている技術
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Node.jsのStreamについて詳しくは以下を参照して下さい。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://jxck.hatenablog.com/entry/20111204/1322966453">Node.js の Stream API で「データの流れ」を扱う方法 - Block Rockin’ Codes</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/shigeki_ohtsu/stream2-kihon">Stream2の基本</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/shigeki_ohtsu/node-v012tng12">Node-v0.12の新機能について</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_promise_7">4.7.5. Promiseラッパー</h4>
<div class="paragraph">
<p>話を戻して<a href="#fs-method-chain.js">fs-method-chain.js</a>と<a href="#fs-promise-chain.js">Promise版</a>の両者を比べると、
内部的にもかなり似ていて、同期版のものがそのまま非同期版でも使えるような気がします。</p>
</div>
<div class="paragraph">
<p>JavaScriptでは動的にメソッドを定義することもできるため、
自動的にPromise版を生成できないかということを考えると思います。
(もちろん静的に定義する方が扱いやすいですが)</p>
</div>
<div class="paragraph">
<p>そのような仕組みは<a href="#es6-promises">ES6 Promises</a>にはありませんが、
著名なサードパーティのPromise実装である <a href="https://github.com/petkaantonov/bluebird/">bluebird</a> などには
<a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> という機能が用意されています。</p>
</div>
<div class="paragraph">
<p>これを利用すると以下のように、その場でpromise版のメソッドを追加して利用できるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> fs = Promise.promisifyAll(require(<span class="string"><span class="delimiter">&quot;</span><span class="content">fs</span><span class="delimiter">&quot;</span></span>));

fs.readFileAsync(<span class="string"><span class="delimiter">&quot;</span><span class="content">myfile.js</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">utf8</span><span class="delimiter">&quot;</span></span>).then(<span class="keyword">function</span>(contents){
    console.log(contents);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(e){
    console.error(e.stack);
});</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_array_promise">ArrayのPromiseラッパー</h5>
<div class="paragraph">
<p>先ほどの <a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> が何をやっているのか少しイメージしにくいので、
次のようなネイティブ <code>Array</code> のPromise版となるメソッドを動的に定義する例を考えてみましょう。</p>
</div>
<div class="paragraph">
<p>JavaScriptにはネイティブにもDOMやString等メソッドチェーンが行える機能が多くあります。
<code>Array</code> もその一つで、<code>map</code> や <code>filter</code> 等のメソッドは配列を返すため、メソッドチェーンが利用しやすい機能です</p>
</div>
<div id="array-promise-chain.js" class="listingblock">
<div class="title">array-promise-chain.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">function</span> <span class="function">ArrayAsPromise</span>(array) {
    <span class="local-variable">this</span>.array = array;
    <span class="local-variable">this</span>.promise = Promise.resolve();
}
ArrayAsPromise.prototype.<span class="function">then</span> = <span class="keyword">function</span> (onFulfilled, onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(onFulfilled, onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
ArrayAsPromise.prototype[<span class="string"><span class="delimiter">&quot;</span><span class="content">catch</span><span class="delimiter">&quot;</span></span>] = <span class="keyword">function</span> (onRejected) {
    <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.<span class="keyword">catch</span>(onRejected);
    <span class="keyword">return</span> <span class="local-variable">this</span>;
};
Object.getOwnPropertyNames(Array.prototype).forEach(<span class="keyword">function</span> (methodName) {
    <span class="comment">// Don't overwrite</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> ArrayAsPromise[methodName] !== <span class="string"><span class="delimiter">&quot;</span><span class="content">undefined</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    <span class="keyword">var</span> arrayMethod = Array.prototype[methodName];
    <span class="keyword">if</span> (<span class="keyword">typeof</span>  arrayMethod !== <span class="string"><span class="delimiter">&quot;</span><span class="content">function</span><span class="delimiter">&quot;</span></span>) {
        <span class="keyword">return</span>;
    }
    ArrayAsPromise.prototype[methodName] = <span class="keyword">function</span> () {
        <span class="keyword">var</span> that = <span class="local-variable">this</span>;
        <span class="keyword">var</span> args = <span class="local-variable">arguments</span>;
        <span class="local-variable">this</span>.promise = <span class="local-variable">this</span>.promise.then(<span class="keyword">function</span> () {
            that.array = Array.prototype[methodName].apply(that.array, args);
            <span class="keyword">return</span> that.array;
        });
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    };
});

module.exports = ArrayAsPromise;
module.exports.<span class="function">array</span> = <span class="keyword">function</span> <span class="function">newArrayAsPromise</span>(array) {
    <span class="keyword">return</span> <span class="keyword">new</span> ArrayAsPromise(array);
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>ネイティブのArrayと <code>ArrayAsPromise</code> を使った場合の違いは
<a href="#array-promise-chain.js">上記のコード</a>のテストを見てみるのが分かりやすいでしょう。</p>
</div>
<div id="array-promise-chain-test.js" class="listingblock">
<div class="title">array-promise-chain-test.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">use strict</span><span class="delimiter">&quot;</span></span>;
<span class="keyword">var</span> assert = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">power-assert</span><span class="delimiter">&quot;</span></span>);
<span class="keyword">var</span> ArrayAsPromise = require(<span class="string"><span class="delimiter">&quot;</span><span class="content">../src/promise-chain/array-promise-chain</span><span class="delimiter">&quot;</span></span>);
describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">array-promise-chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
    <span class="keyword">function</span> <span class="function">isEven</span>(value) {
        <span class="keyword">return</span> value % <span class="integer">2</span> === <span class="integer">0</span>;
    }

    <span class="keyword">function</span> <span class="reserved">double</span>(value) {
        <span class="keyword">return</span> value * <span class="integer">2</span>;
    }

    beforeEach(<span class="keyword">function</span> () {
        <span class="local-variable">this</span>.array = [<span class="integer">1</span>, <span class="integer">2</span>, <span class="integer">3</span>, <span class="integer">4</span>, <span class="integer">5</span>];
    });
    describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">Native array</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">can method chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
            <span class="keyword">var</span> result = <span class="local-variable">this</span>.array.filter(isEven).map(<span class="reserved">double</span>);
            assert.deepEqual(result, [<span class="integer">4</span>, <span class="integer">8</span>]);
        });
    });
    describe(<span class="string"><span class="delimiter">&quot;</span><span class="content">ArrayAsPromise</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> () {
        it(<span class="string"><span class="delimiter">&quot;</span><span class="content">can promise chain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">function</span> (done) {
            <span class="keyword">var</span> array = <span class="keyword">new</span> ArrayAsPromise(<span class="local-variable">this</span>.array);
            array.filter(isEven).map(<span class="reserved">double</span>).then(<span class="keyword">function</span> (value) {
                assert.deepEqual(value, [<span class="integer">4</span>, <span class="integer">8</span>]);
            }).then(done, done);
        });
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ArrayAsPromise</code> でもArrayのメソッドを利用できているのが分かります。
先ほどと同じように、ネイティブのArrayは同期処理で、<code>ArrayAsPromise</code> は非同期処理という違いがあります。</p>
</div>
<div class="paragraph">
<p><code>ArrayAsPromise</code> の実装を見て気づくと思いますが、<code>Array.prototype</code> のメソッドを全て実装しています。
しかし、<code>array.indexOf</code> など <code>Array.prototype</code> には配列を返さないものもあるため、全てをメソッドチェーンにするのは不自然なケースがあると思います。</p>
</div>
<div class="paragraph">
<p>ここで大事なのが、同じ値を受けるインターフェースを持っているAPIはこのような手段でPromise版のAPIを自動的に作成できるという点です。
このようなAPIの規則性を意識してみるとまた違った使い方が見つかるかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>先ほどの <a href="https://github.com/petkaantonov/bluebird/blob/master/API.md#promisification">Promisification</a> は
Node.jsのCoreモジュールの非同期処理には <code>function(error,result){}</code> というように第一引数に <code>error</code> が来るというルールを利用して、
自動的にPromiseでラップしたメソッドを生成しています</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__27">4.7.6. まとめ</h4>
<div class="paragraph">
<p>このセクションでは以下のことについて学びました。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Promise版のメソッドチェーンの実装</p>
</li>
<li>
<p>Promiseが常に非同期の最善の手段ではない</p>
</li>
<li>
<p>Promisification</p>
</li>
<li>
<p>統一的なインターフェースの再利用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#es6-promises">ES6 Promises</a>はCoreとなる機能しか用意されていません。
そのため、自分でPromiseを使った既存の機能のラッパー的な実装をする事があるかもしれません。</p>
</div>
<div class="paragraph">
<p>しかし、何度もコールバックを呼ぶEventのような処理がPromiseには不向きなように、
Promiseが常に最適な非同期処理という訳ではありません。</p>
</div>
<div class="paragraph">
<p>その機能にPromiseを使うのが最適なのかを考える事はこの書籍の目的でもあるため、
何でもPromiseにするというわけではなく、その目的にPromiseが合うのかどうかを考えてみるのもいいと思います。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="promise-sequence">4.8. Promiseによる逐次処理</h3>
<div class="paragraph">
<p>第2章の<a href="#ch2-promise-all">Promise.all</a>では、
複数のpromiseオブジェクトをまとめて処理する方法について学びました。</p>
</div>
<div class="paragraph">
<p>しかし、<code>Promise.all</code> は全ての処理を並行に行うため、
Aの処理 が終わったら Bの処理 というような逐次的な処理を扱うことが出来ません。</p>
</div>
<div class="paragraph">
<p>また、同じ2章の<a href="#ch2-promise-and-array">Promiseと配列</a>では、
効率的ではないですが、<a href="#multiple-xhr.js">thenを連ねた書き方</a>でそのような逐次処理を行っていました。</p>
</div>
<div class="paragraph">
<p>このセクションでは、Promiseを使った逐次処理の書き方について学んで行きたいと思います。</p>
</div>
<div class="sect3">
<h4 id="__28">4.8.1. ループと逐次処理</h4>
<div class="paragraph">
<p><a href="#multiple-xhr.js">thenを連ねた書き方</a>では以下のような書き方でしたね。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] は記録する初期値を部分適用している</span>
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> request.comment().then(pushValue).then(request.people).then(pushValue);
}
<span class="comment">// 実行例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>この書き方だと、<code>request</code> の数が増える分 <code>then</code> を書かないといけなくなってしまいます。</p>
</div>
<div class="paragraph">
<p>そこで、処理を配列にまとめて、forループで処理していければ、数が増えた場合も問題無いですね。
まずはforループを使って先ほどと同じ処理を書いてみたいと思います。</p>
</div>
<div id="promise-foreach-xhr.js" class="listingblock executable">
<div class="title">promise-foreach-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="comment">// [] は記録する初期値を部分適用してる</span>
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="comment">// promiseオブジェクトを返す関数の配列</span>
    <span class="keyword">var</span> tasks = [request.comment, request.people];
    <span class="keyword">var</span> promise = Promise.resolve();
    <span class="comment">// スタート地点</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="integer">0</span>; i &lt; tasks.length; i++) {
        <span class="keyword">var</span> task = tasks[i];
        promise = promise.then(task).then(pushValue);
    }
    <span class="keyword">return</span> promise;
}
<span class="comment">// 実行例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>forループで書く場合、<a href="#then-return-new-promise">コラム: thenは常に新しいpromiseオブジェクトを返す</a>や<a href="#promise-and-method-chain">Promiseとメソッドチェーン</a>で学んだように、
<a href="#promise.then">Promise#then</a> は新しいpromiseオブジェクトを返しています。</p>
</div>
<div class="paragraph">
<p>そのため、<code>promise = promise.then(task).then(pushValue);</code> というのは <code>promise</code> という変数に上書きするというよりは、
そのpromiseオブジェクトに処理を追加していくような処理になっています。</p>
</div>
<div class="paragraph">
<p>しかし、この書き方だと一時変数として <code>promise</code> が必要で、処理の内容的にもあまりスッキリしません。</p>
</div>
<div class="paragraph">
<p>このループの書き方は <code>Array.prototype.reduce</code> を使うともっとスマートに書くことが出来ます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_promise_chain_reduce">4.8.2. Promise chainとreduce</h4>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> を使って書き直すと以下のようになります。</p>
</div>
<div id="promise-reduce-xhr.js" class="listingblock executable">
<div class="title">promise-reduce-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">var</span> tasks = [request.comment, request.people];
    <span class="keyword">return</span> tasks.reduce(<span class="keyword">function</span> (promise, task) {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}
<span class="comment">// 実行例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>main</code> 以外の処理はforループのものと同様です。</p>
</div>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> は第二引数に初期値を入れることができます。
つまりこの場合、最初の <code>promise</code> には <code>Promise.resolve()</code> が入り、
そのときの <code>task</code> は <code>request.comment</code> となります。</p>
</div>
<div class="paragraph">
<p>reduceの中で <code>return</code> したものが、次のループで <code>promise</code> に入ります。
つまり、<code>then</code> を使って作成した新たなpromiseオブジェクトを返すことで、
forループの場合と同じように<a href="#promise-chain">Promise chain</a>を繋げることが出来ます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Array.prototype.reduce</code> については詳しくは以下を参照して下さい。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">Array.prototype.reduce() - JavaScript | MDN</a></p>
</li>
<li>
<p><a href="http://glide.so/azu/6919649">azu / Array.prototype.reduce Dance - Glide</a></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>forループと異なる点は、一時変数としての <code>promise</code> が不要になることに伴い、
<code>promise = promise.then(task).then(pushValue);</code> という不格好な書き方がなくなる点が大きな違いだと思います。</p>
</div>
<div class="paragraph">
<p><code>Array.prototype.reduce</code> とPromiseの逐次処理は相性が良いので覚えておくといいのですが、
初めて見た時にどういう動作をするのかがまだ分かりにくいという問題があります。</p>
</div>
<div class="paragraph">
<p>そこで、処理するTaskとなる関数の配列を受け取って逐次処理を行う
<code>sequenceTasks</code> というものを作ってみます。</p>
</div>
<div class="paragraph">
<p>以下のように書くことができれば、<code>tasks</code> が順番に処理されていく事が関数名から見てわかるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> tasks = [request.comment, request.people];
sequenceTasks(tasks);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__29">4.8.3. 逐次処理を行う関数を定義する</h4>
<div class="paragraph">
<p>基本的には、<a href="#promise-reduce-xhr.js">reduceを使ったやり方</a>を関数として切り離せばいいだけですね。</p>
</div>
<div id="promise-sequence.js" class="listingblock">
<div class="title">promise-sequence.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">sequenceTasks</span>(tasks) {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> tasks.reduce(<span class="keyword">function</span> (promise, task) {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一つ注意点として、<code>Promise.all</code> 等と違い、引数に受け取るのは関数の配列です。</p>
</div>
<div class="paragraph">
<p>何故、渡すのがpromiseオブジェクトの配列ではないのかというと、
promiseオブジェクトを作った段階で既にXHRが実行されている状態なので、
それを逐次処理しても意図とは異なる動作になるためです。</p>
</div>
<div class="paragraph">
<p>そのため <code>sequenceTasks</code> では関数(promiseオブジェクトを返す)の配列を引数に受け取ります。</p>
</div>
<div class="paragraph">
<p>最後に、<code>sequenceTasks</code> を使って最初の例を書き換えると以下のようになります。</p>
</div>
<div id="promise-sequence-xhr.js" class="listingblock executable">
<div class="title">promise-sequence-xhr.js</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">function</span> <span class="function">sequenceTasks</span>(tasks) {
    <span class="keyword">function</span> <span class="function">recordValue</span>(results, value) {
        results.push(value);
        <span class="keyword">return</span> results;
    }
    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="predefined-constant">null</span>, []);
    <span class="keyword">return</span> tasks.reduce(<span class="keyword">function</span> (promise, task) {
        <span class="keyword">return</span> promise.then(task).then(pushValue);
    }, Promise.resolve());
}
<span class="keyword">function</span> <span class="function">getURL</span>(URL) {
    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="keyword">function</span> (resolve, reject) {
        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();
        req.open(<span class="string"><span class="delimiter">'</span><span class="content">GET</span><span class="delimiter">'</span></span>, URL, <span class="predefined-constant">true</span>);
        req.<span class="function">onload</span> = <span class="keyword">function</span> () {
            <span class="keyword">if</span> (req.status == <span class="integer">200</span>) {
                resolve(req.response);
            } <span class="keyword">else</span> {
                reject(<span class="keyword">new</span> Error(req.statusText));
            }
        };
        req.<span class="function">onerror</span> = <span class="keyword">function</span> () {
            reject(<span class="keyword">new</span> Error(req.statusText));
        };
        req.send();
    });
}
<span class="keyword">var</span> request = {
        <span class="function">comment</span>: <span class="keyword">function</span> <span class="function">getComment</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/comment.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        },
        <span class="function">people</span>: <span class="keyword">function</span> <span class="function">getPeople</span>() {
            <span class="keyword">return</span> getURL(<span class="string"><span class="delimiter">'</span><span class="content">http://azu.github.io/promises-book/json/people.json</span><span class="delimiter">'</span></span>).then(JSON.parse);
        }
    };
<span class="keyword">function</span> <span class="function">main</span>() {
    <span class="keyword">return</span> sequenceTasks([request.comment, request.people]);
}
<span class="comment">// 実行例</span>
main().then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span>(error){
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>main()</code> の中がかなりスッキリしたことが分かります。</p>
</div>
<div class="paragraph">
<p>このようにPromiseでは、逐次処理という事をするのに色々な書き方が出来ると思います。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#multiple-xhr.js">thenをその場に並べた書き方</a></p>
</li>
<li>
<p><a href="#promise-foreach-xhr.js">forループを使った書き方</a></p>
</li>
<li>
<p><a href="#promise-reduce-xhr.js">reduceを使った書き方</a></p>
</li>
<li>
<p><a href="#promise-sequence.js">逐次処理する関数を分けた書き方</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>しかし、これはJavaScriptで配列を扱うのにforループや <code>forEach</code> 等、色々やり方があるのと本質的には違いはありません。
そのため、Promiseを扱う場合も処理をまとめられるところは小さく関数に分けて、実装していくのがいいと言えるでしょう。</p>
</div>
</div>
<div class="sect3">
<h4 id="__30">4.8.4. まとめ</h4>
<div class="paragraph">
<p>このセクションでは、<a href="#Promise.all"><code>Promise.all</code></a>とは違い、
一つづつ順番に処理したい場合に、Promiseでどのように実装していくかについて学びました。</p>
</div>
<div class="paragraph">
<p>手続き的な書き方から、逐次処理を行う関数を定義するところまで見ていき、
Promiseであっても関数に処理を分けるという基本的な事は変わらないことを示しました。</p>
</div>
<div class="paragraph">
<p>Promiseで書くとPromise chainを繋げすぎて縦に長い処理を書いてしまうことがあります。</p>
</div>
<div class="paragraph">
<p>そんな時は基本に振り返り、処理を関数に分けることで全体の見通しを良くすることは大切です。</p>
</div>
<div class="paragraph">
<p>また、Promiseのコンストラクタ関数や <code>then</code> 等は高階関数なので、
処理を関数に分けておくと組み合わせが行い易いという副次的な効果もあるため、意識してみるといいかもしれません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
高階関数とは引数に関数オブジェクトを受け取る関数のこと
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="promise-api-reference">5. Promises API Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="promise.then">5.1. Promise#then</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.then(onFulfilled, onRejected);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">thenコード例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">thenに渡す値</span><span class="delimiter">&quot;</span></span>);
});
promise.then(<span class="keyword">function</span> (value) {
    console.log(value);
}, <span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>promiseオブジェクトに対してonFulfilledとonRejectedのハンドラを定義し、
新たなpromiseオブジェクトを作成して返す。</p>
</div>
<div class="paragraph">
<p>このハンドラはpromiseがresolve または rejectされた時にそれぞれ呼ばれる。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>定義されたハンドラ内で返した値は、新たなpromiseオブジェクトのonFulfilledに対して渡される。</p>
</li>
<li>
<p>定義されたハンドラ内で例外が発生した場合は、新たなpromiseオブジェクトのonRejectedに対して渡される。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="promise.catch">5.2. Promise#catch</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">promise.<span class="keyword">catch</span>(onRejected);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">catchのコード例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> promise = <span class="keyword">new</span> Promise(<span class="keyword">function</span>(resolve, reject){
    resolve(<span class="string"><span class="delimiter">&quot;</span><span class="content">thenに渡す値</span><span class="delimiter">&quot;</span></span>);
});
promise.then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>promise.then(undefined, onRejected)</code> と同等の意味を持つシンタックスシュガー。</p>
</div>
</div>
<div class="sect2">
<h3 id="Promise.resolve">5.3. Promise.resolve</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.resolve(promise);
Promise.resolve(thenable);
Promise.resolve(object);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.resolveのコード例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> taskName = <span class="string"><span class="delimiter">&quot;</span><span class="content">task 1</span><span class="delimiter">&quot;</span></span>
asyncTask(taskName).then(<span class="keyword">function</span> (value) {
    console.log(value);
}).<span class="keyword">catch</span>(<span class="keyword">function</span> (error) {
    console.error(error);
});
<span class="keyword">function</span> <span class="function">asyncTask</span>(name){
    <span class="keyword">return</span> Promise.resolve(name).then(<span class="keyword">function</span>(value){
        <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">Done! </span><span class="delimiter">&quot;</span></span>+ value;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>受け取った値に応じたpromiseオブジェクトを返す。</p>
</div>
<div class="paragraph">
<p>どの場合でもpromiseオブジェクトを返すが、大きく分けて以下の3種類となる。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">promiseオブジェクトを受け取った場合</dt>
<dd>
<p>受け取ったpromiseオブジェクトをそのまま返す</p>
</dd>
<dt class="hdlist1">thenableなオブジェクトを受け取った場合</dt>
<dd>
<p><code>then</code> を持つオブジェクトを新たなpromiseオブジェクトにして返す</p>
</dd>
<dt class="hdlist1">その他の値(オブジェクトやnull等も含む)を受け取った場合</dt>
<dd>
<p>その値でresolveされる新たなpromiseオブジェクトを作り返す</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="Promise.reject">5.4. Promise.reject</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.reject(object)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Promise.rejectのコード例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> failureStub = sinon.stub(xhr, <span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span>).returns(Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">bad!</span><span class="delimiter">&quot;</span></span>)));</code></pre>
</div>
</div>
<div class="paragraph">
<p>受け取った値でrejectされた新たなpromiseオブジェクトを返す。</p>
</div>
<div class="paragraph">
<p>Promise.rejectに渡す値は <code>Error</code> オブジェクトとすべきである。</p>
</div>
<div class="paragraph">
<p>また、Promise.resolveとは異なり、promiseオブジェクトを渡した場合も常に新たなpromiseオブジェクトを作成する。</p>
</div>
<div class="listingblock executable">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> r = Promise.reject(<span class="keyword">new</span> Error(<span class="string"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>));
console.log(r === Promise.reject(r));<span class="comment">// false</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="Promise.all">5.5. Promise.all</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.all(promiseArray);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.allのコード例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> p1 = Promise.resolve(<span class="integer">1</span>),
    p2 = Promise.resolve(<span class="integer">2</span>),
    p3 = Promise.resolve(<span class="integer">3</span>);
Promise.all([p1, p2, p3]).then(<span class="keyword">function</span> (results) {
    console.log(results);  <span class="comment">// [1, 2, 3]</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>新たなpromiseオブジェクトを作成して返す。</p>
</div>
<div class="paragraph">
<p>渡されたpromiseオブジェクトの配列が全てresolveされた時に、
新たなpromiseオブジェクトはその値でresolveされる。</p>
</div>
<div class="paragraph">
<p>どれかの値がrejectされた場合は、その時点で新たなpromiseオブジェクトはrejectされる。</p>
</div>
<div class="paragraph">
<p>渡された配列の値はそれぞれ <code>Promise.resolve</code> にラップされるため、
promiseオブジェクト以外が混在している場合も扱える。</p>
</div>
</div>
<div class="sect2">
<h3 id="Promise.race">5.6. Promise.race</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript">Promise.race(promiseArray);</code></pre>
</div>
</div>
<div class="listingblock executable">
<div class="title">Promise.raceのコード例</div>
<div class="content">
<pre class="CodeRay"><code class="javascript language-javascript"><span class="keyword">var</span> p1 = Promise.resolve(<span class="integer">1</span>),
    p2 = Promise.resolve(<span class="integer">2</span>),
    p3 = Promise.resolve(<span class="integer">3</span>);
Promise.race([p1, p2, p3]).then(<span class="keyword">function</span> (value) {
    console.log(value);  <span class="comment">// 1</span>
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>新たなpromiseオブジェクトを作成して返す。</p>
</div>
<div class="paragraph">
<p>渡されたpromiseオブジェクトの配列のうち、
一番最初にresolve または rejectされたpromiseにより、
新たなpromiseオブジェクトはその値でresolve または rejectされる。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="promise-glossary">6. 用語集</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Promises</dt>
<dd>
<p>プロミスという仕様そのもの</p>
</dd>
<dt class="hdlist1">promiseオブジェクト</dt>
<dd>
<p>プロミスオブジェクト、<code>Promise</code> のインスタンスオブジェクトの事</p>
</dd>
</dl>
</div>
<div id="es6-promises" class="dlist">
<dl>
<dt class="hdlist1">ES6 Promises</dt>
<dd>
<p><a href="http://people.mozilla.org/%7Ejorendorff/es6-draft.html#sec-operations-on-promise-objects">ECMAScript 6th Edition</a> を明示的に示す場合にprefixとして <em>ES6</em> をつける</p>
</dd>
</dl>
</div>
<div id="promises-aplus" class="dlist">
<dl>
<dt class="hdlist1">Promises/A+</dt>
<dd>
<p><a href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a>の事。
ES6 Promisesの前身となったコミュニティベースの仕様であり、ES6 Promisesとは多くの部分が共通している。</p>
</dd>
</dl>
</div>
<div id="Thenable" class="dlist">
<dl>
<dt class="hdlist1">Thenable</dt>
<dd>
<p>Promiseライクなオブジェクトの事。
<code>.then</code> というメソッドを持つオブジェクト。</p>
</dd>
</dl>
</div>
<div id="promise-chain" class="dlist">
<dl>
<dt class="hdlist1">promise chain</dt>
<dd>
<p>promiseオブジェクトを <code>then</code> や <code>catch</code> のメソッドチェーンでつなげたもの。
この用語は書籍中のものであり、<a href="#es6-promises">ES6 Promises</a>で定められた用語ではありません。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="resouce-link">7. 参考サイト</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="https://github.com/w3ctag/promises-guide">w3ctag/promises-guide</a></dt>
<dd>
<p>Promisesのガイド - 概念的な説明はここから得たものが多い</p>
</dd>
<dt class="hdlist1"><a href="https://github.com/domenic/promises-unwrapping">domenic/promises-unwrapping</a></dt>
<dd>
<p>ES6 Promisesの仕様リポジトリ - issueを検索して得た経緯や情報も多い</p>
</dd>
<dt class="hdlist1"><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">ECMAScript Language Specification ECMA-262 6th Edition – DRAFT</a></dt>
<dd>
<p>ES6 Promisesの仕様書 - 仕様書として参照する場合はこちらを優先した</p>
</dd>
<dt class="hdlist1"><a href="http://www.html5rocks.com/en/tutorials/es6/promises/?redirect_from_locale=ja">JavaScript Promises: There and back again - HTML5 Rocks</a></dt>
<dd>
<p>Promisesについての記事 - 完成度がとても高くサンプルコードやリファレンス等を参考にした</p>
</dd>
<dt class="hdlist1"><a href="http://d.hatena.ne.jp/jovi0608/20140319/1395199285">Node.jsにPromiseが再びやって来た！ - ぼちぼち日記</a></dt>
<dd>
<p>Node.jsとPromiseの記事 - <em>thenable</em>について参考にした</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about-author">8. 著者について</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="Appendix-Glossary/img/simple320_320.png" alt="azu" width="32" height="32"></span>
<strong><a href="https://github.com/azu/">azu</a></strong> (Twitter : @<a href="https://twitter.com/azu_re">azu_re</a> )</p>
</div>
<div class="paragraph">
<p>ブラウザ、JavaScriptの最新技術を常に追いかけている。</p>
</div>
<div class="paragraph">
<p>目的を手段にしてしまうことを得意としている(この書籍もその結果できた)。</p>
</div>
<div class="paragraph">
<p><a href="http://efcl.info/">Web Scratch</a> や <a href="http://jser.info/">JSer.info</a> といったサイトを運営している。</p>
</div>
<div class="sect2">
<h3 id="omake-message">8.1. 著者へのメッセージ/おまけ</h3>
<div class="paragraph">
<p>以下の <a href="https://gumroad.com/l/javascript-promise">おまけ.pdf</a> では、
この書籍を書き始めた理由や、どのように書いていったか、テストなどについて書かれています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><a class="image" href="https://gumroad.com/l/javascript-promise"><img src="public/img/gumroad-green.svg" alt="おまけをダウンロード"></a></span> <a href="https://gumroad.com/l/javascript-promise">JavaScript Promiseの本のおまけ</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Gumroadから無料 または 好きな値段でダウンロードすることが出来ます。</p>
</div>
<div class="paragraph">
<p>ダウンロードする際に作者へのメッセージも書けるので、
メッセージを残すついでにダウンロードして行ってください。</p>
</div>
<div class="paragraph">
<p>問題の指摘などがありましたら、GitHubやGitterに書いてくださると解決出来ます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/azu/promises-book/issues?state=open">Issues · azu/promises-book</a></p>
</li>
<li>
<p><a href="https://gitter.im/azu/promises-book">azu/promises-book - Gitter</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.1.2<br>
Last updated 2014-07-18 22:48:57 CST
</div>
</div>
</body>
</html>